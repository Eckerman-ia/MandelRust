<!DOCTYPE html>
<!--
    Web page written by David Eck, http://math.hws.edu/eck/index.html
    You can do anything you like with this web page and with the code, but
    if you use a substantial portion of it, you should include attribution.

    This is a fairly complete "Mandelbrot Set" viewer program, including
    the ability to do arbitrary precision computation (very slowly) when you
    zoom in too far to do the calculations with regular floating point numbers.

    It can save and load examples as XML in a clunky way, by copy-and-paste
    between files and a textarea that appears when "Show XML Input/Export"
    is clicked.  All of the ideas and some of the code were ported from
    an older program that was written in java.
    
    This file depends on the scripts mandelbrot-worker-remote.js, mandelbrot-worker-local.js, slider.js,
    and Daniel Trebbien's BigDecimal-all-last.min.js.

    August, 2019. Added Palette Editor.
    January, 2020. Improved Palette Editor.
    April, 2020.  Cleaned up standard palettes, removed a few, added Dark Colors palette.
    May, 2020.  Change maximum image width and height from 2500 to 10000 (but that
        doesn't necessarily mean very large images will work on every device).
    October, 2021.  Fixed a bug in startJob() and startSecondPass() that showed up
        when the change in y-value from one line to the next is very small.  This was
        done previously by successive subtraction, which introduced errors.  Thanks to
        Robert Munafo for finding and fixing the bug.
    August, 2022.  Use localStorage to save workerCount between sessions.

    Changes by Bill Wood:
    Jul/Aug 2019: Rewrote job processing to be client/server, also fixed y-value issue as above
                  Changed HP_CUTOFF from 16 to 15 to avoid artifacts at the limits of f64 precision
                  Added "High Precision" toggle and rows/second info
    Jan-Mar 2023: Rewrote JavaScript server in Rust to get 10 times speedup in high precision computations
                  When zooming, the zoomed area is displayed using image interpolation while calculations are done
                  Left, right, up, and down arrow key bindings shift the image appropriately; page down and page up zoom in and out
                  Max image width/height is now 7680 (8K)
                  Fixed off by factor of 10 error in zoom out by 10,000 and 100,000
                  Added option to run calculations locally on the browser in JavaScript, or on the backend Rust server
                  Added undo (ctrl-z) and redo (ctrl-shift-z and ctrl-y) key bindings
                  Fixed small bug where dx value was being used to increment yval instead of dy value in HP calculations
                  Rewrote browser-side computations from JavaScript to Rust WASM
                  Added interactive sliders for control of max iterations, zoom level, palette offset, etc.
                  Added undo/redo with image interpolation for zoom.
                  Added full window mode, activated with "f" and deactivated with "f" or escape.
                  Added full screen mode, activated with "F" and deactivated with "F", "f", or escape.
-->
<html>
<head>
<meta charset="UTF-8">
<title>Mandelbrot Viewer</title>
<!--
<meta property="og:image" content="https://mandelbrot.xxxxxx.com/thumbnail.png"/>
<meta property="og:url" content="https://mandelbrot.xxxxxx.com/MB.html"/>
-->
<meta property="og:type" content="website"/>
<meta property="og:title" content="Mandelbrot Viewer" />
<meta property="og:description" content="This Mandelbrot viewer, originally by David Eck, has been rewritten with a Rust backend, considerably speeding it up."/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
<style type="text/css">
   body {
       background-color: #e8ecf3;
   }
   canvas {
       display: block;
       background-color: #BBBBBB;
   }
   .FullWindowCanvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
   }
   #canvas-holder {
       display: inline-block;
       border: 2px solid black;
       margin: 0;
       padding: 0;
   }
   #controls {
       display: inline-block;
       background-color:white;
       border: 2px solid black;
       padding: 0;
       margin-right:10px;
       border-radius: 8px;
   }
   #controls p {
       margin: 12px 0;
       white-space: nowrap;
   }
   div.group {
       padding: 0 8px;
       border-bottom: 1px solid black;
   }
   div.grouplast {
       padding: 0 8px;
   }
   #imagediv p {
       margin: 4px 0;
       white-space: nowrap;
   }
   #imagediv {
       margin-left: 20px;
       padding: 0;
   }
   #status {
       white-space: nowrap;
       font-weight: bold;
       color: #AA0000;
   }
   #xmlimportbg {
       position: fixed;
       z-index: 10;
       opacity: 0.7;
       background-color: black;
       left: 0;
       top: 0;
       width: 100%;
       height: 100%;
       display: none;
   }
   #xmlimport, #paletteEditor {
       position: absolute;
       left: 70px;
       top: 100px;
       z-index:20;
       padding: 10px;
       background-color: #D8D8FF;
       border: 2px solid #000099;
       border-radius: 16px;
       box-shadow: 5px 5px 8px black;
       display: none;
   }
   textarea {
     white-space: pre;
     word-wrap: normal;
     overflow-x: scroll;
   }
    body {
        font-family: Arial, sans-serif;
    }

    /* Style the tooltip container */
    .tooltip {
        position: relative;
        display: inline-block;
        font-weight: normal;
    }
    /* Style the tooltip text */
    .tooltip .helptext {
        visibility: hidden;
        width: 800px;
        background-color: #fff;
        color: #000;
        text-align: left;
        border-radius: 8px;
        padding: 10px;
        position: absolute;
        z-index: 1;
        font-size: 16px;
        font-weight: normal;
        top: 100%;
        left: 100%;
        transform: translateX(-40%);
        border: 1px solid black;
    }
    /* Show the tooltip text when hovering over the container */
    .tooltip:hover .helptext {
        visibility: visible;
    }
    /* Format the tooltip arrow */
    .tooltip .helptext::after {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 41%;
        border-width: 5px;
        border-style: solid;
        border-color: #555 transparent transparent transparent;
    }
    /* Style the tooltip text */
    .tooltip .exampletext {
        visibility: hidden;
        width: 800px;
        background-color: #fff;
        color: #000;
        text-align: left;
        border-radius: 8px;
        padding: 10px;
        position: absolute;
        z-index: 1;
        font-size: 16px;
        font-weight: normal;
        top: 100%;
        left: 100%;
        transform: translateX(-65%);
        border: 1px solid black;
    }
    /* Show the tooltip text when hovering over the container */
    .tooltip:hover .exampletext {
        visibility: visible;
    }
    /* Format the tooltip arrow */
    .tooltip .exampletext::after {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 66%;
        border-width: 5px;
        border-style: solid;
        border-color: #555 transparent transparent transparent;
    }

    #header-table {
        border-collapse: collapse;
        width: 100%;
        font-size: 22px;
        table-layout: fixed;
    }
    #header-table > tbody > tr > td {
        text-align: Left;
    }
    #header-table > tbody > tr > td:first-child {
        width: 30%;
    }
    #header-table > tbody > tr > td:nth-child(2) {
        width: 20%;
        text-align: center;
    }

    #examples td, #examples tr {
        margin: 0;
        padding: 0;
    }
    #examples {
        padding: 0;
        margin: 7px auto;
        border: 2px solid darkgray;
        border-spacing: 0;
    }
    #examples td {
        border: 2px solid darkgray;
        max-width: 33.33%;
    }
    #examples img, #examples a {
        max-width: 100%;
        height: auto;
        display: block;
    }

  </style>
</style>

<script src="BigDecimal-all-last.min.js"></script>
<script src="slider.js"></script>
<script>

"use strict";

var HP_CUTOFF_EXP = 15;
var HP_CUTOFF = new BigDecimal("1e-15");
var TEN = new BigDecimal("10");
var TWO = new BigDecimal("2");


var OSC;  // Off-screen canvas, holds the the Mandelbrot set.
var OSG;  // Graphics context for off-screen canvas.
var canvas;    // On-screen canvas -- shows OSC, with stuff possibly drawn on top.
var graphics;  // Graphics context for on-screen canvas.

var ArrayType = window.Uint32Array || Array;

var workers;
let jobNum = 0, highestJobNumFinished = 0;

var running = false;
var repaintTimeout;
const repaintTimer = 750, repaintInitialTimer = 333;

var /* BigDecimal */ xmin_requested, ymin_requested, xmax_requested, ymax_requested;
var /* BigDecimal */ xmin, ymin, xmax, ymax;
var /* BigDecimal */ dx, dy;
var /* Uint32Array */ xminArray, yValArray, dxArray;

var jobs;
var workerCount = 4;
let jobStartTime;
let rowsCompleted, rowsPerSecond;
var highPrecision;

var COMPUTING_FIRST_PASS = 1, DONE_FIRST_PASS = 2, COMPUTING_SECOND_PASS = 3, IDLE = 4;
var state = IDLE;

var dragbox = null;

let maxIterSlider, mainPaletteOffsetSlider, mainPaletteLengthSlider, paletteSelectSlider;
let zoomInSlider, zoomOutSlider;
let fitWindow;

var palette;
var fixedPaletteLength;
var paletteLength;
var paletteColors;

var savedIterationCounts;
var savedIterationCounts2ndPass;

var imageData, hres, vres;  // for setting pixel colors.

var currentXML = null;

var undoList = null; // will be an array; null here prevents SetDefaults from adding a spurious undo item
var undoCount = 0;
var applyUndoInProgress = false;

var paletteEditInProgress = false;

var interlaced = true;
var interlaceOrder = (function() {
      var order = [127];
      for (var i = 64; i >= 1; i /= 2) {
          var ct = order.length;
          for (var j = 0; j < ct; j++) {
              order.push(order[j] - i);
          }
      }
      return order;
   })();

var digits, chunks;
var /* BigDecimal */ twoTo16 = new BigDecimal("65536");
var log2of10 = Math.log(10)/Math.log(2);

let compute_mandelbrot;
WebAssembly
    .compileStreaming(fetch("mb-wasm.wasm"))
    .then(wasmModule => {
        compute_mandelbrot = wasmModule;
        init();
    });

function convert( /* int[] */ x, /* BigDecimal */ X, /* int */ count) {
    var neg = false;
    if (X.signum() == -1) {
        neg = true;
        X = X.negate();
    }
    x[0] = Number(X.setScale(0,BigDecimal.ROUND_DOWN).toString());
    for (var i = 1; i < count; i++) {
        X = X.subtract(new BigDecimal(""+x[i-1]));
        X = X.multiply(twoTo16);
        x[i] = Number(X.setScale(0,BigDecimal.ROUND_DOWN).toString());
    }
    if (neg) {
        negate(x,count);
    }
    function negate( /* int[] */ x, /* int */ chunks) {
        for (var i = 0; i < chunks; i++)
            x[i] = 0xFFFF-x[i];
        ++x[chunks-1];
        for (var i = chunks-1; i > 0 && (x[i] & 0x10000) != 0; i--) {
            x[i] &= 0xFFFF;
            ++x[i-1];
        }
        x[0] &= 0xFFFF;
    }
}

function setLimits(x1, x2, y1, y2, recordUndo) {
    var oldLimits = [xmin_requested,xmax_requested,ymin_requested,ymax_requested];
    xmin_requested = x1;
    xmax_requested = x2;
    ymin_requested = y1;
    ymax_requested = y2;
    if (xmax_requested.compareTo(xmin_requested) < 0) {
       var temp = xmin_requested;
       xmin_requested = xmax_requested;
       xmax_requested = temp;
    }
    if (ymax_requested.compareTo(ymin_requested) < 0) {
       var temp = ymax_requested;
       ymax_requested = ymin_requested;
       ymin_requested = temp;
    }
    checkAspect();
    if (recordUndo) {
        addUndoItem("Change Limits", oldLimits, [xmin_requested,xmax_requested,ymin_requested,ymax_requested]);
    }
}

function checkAspect() {  // adjust requested x/y limits to match aspect ratio of image
    xmin = xmin_requested;
    xmax = xmax_requested;
    ymin = ymin_requested;
    ymax = ymax_requested;
    if (xmin.scale() < HP_CUTOFF_EXP + 8)
        xmin = xmin.setScale(HP_CUTOFF_EXP + 8);
    if (xmax.scale() < HP_CUTOFF_EXP + 8)
        xmax = xmax.setScale(HP_CUTOFF_EXP + 8);
    if (ymin.scale() < HP_CUTOFF_EXP + 8)
        ymin = ymin.setScale(HP_CUTOFF_EXP + 8);
    if (ymax.scale() < HP_CUTOFF_EXP + 8)
        ymax = ymax.setScale(HP_CUTOFF_EXP + 8);
    var dx = xmax.subtract(xmin).setScale(Math.max(xmax.scale(),HP_CUTOFF_EXP)*2, BigDecimal.ROUND_HALF_EVEN);
    dx = dx.divide(new BigDecimal("" + canvas.width),BigDecimal.ROUND_HALF_EVEN);
    var precision = 0;
    while (dx.compareTo(TWO) < 0) {
       precision++;
       dx = dx.multiply(TEN);
    }
    if (precision < HP_CUTOFF_EXP)
        precision = HP_CUTOFF_EXP;
    var scale = precision + 5 + Math.floor((precision-10)/10);
    xmin = xmin.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    xmax = xmax.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    ymin = ymin.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    ymax = ymax.setScale(scale,BigDecimal.ROUND_HALF_EVEN);

    var width = xmax.subtract(xmin);
    var height = ymax.subtract(ymin);
    var aspect = width.divide(height,BigDecimal.ROUND_HALF_EVEN);
    var windowAspect = new BigDecimal( "" + canvas.width/canvas.height );
    if (aspect.compareTo(windowAspect) < 0) {
        var newWidth = width.multiply(windowAspect).divide(aspect,BigDecimal.ROUND_HALF_EVEN);
        var center = xmax.add(xmin).divide(TWO,BigDecimal.ROUND_HALF_EVEN);
        xmax = center.add(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale, BigDecimal.ROUND_HALF_EVEN);
        xmin = center.subtract(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    }
    else if (aspect.compareTo(windowAspect) > 0) {
        var newHeight = height.multiply(aspect).divide(windowAspect,BigDecimal.ROUND_HALF_EVEN);
        var center = ymax.add(ymin).divide(TWO,BigDecimal.ROUND_HALF_EVEN);
        ymax = center.add(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
        ymin = center.subtract(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    }
}

function doDraw() {
    // console.log("doDraw from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (zoomTimeout) {
        clearInterval(zoomTimeout);
        zoomTimeout = null;
    }
    graphics.drawImage(OSC,0,0);
    if (dragbox && dragbox.width > 2 && dragbox.height > 2) {
       dragbox.draw();
    }
}

function repaint(dontUpdateStatusToIdle) {
    // console.log("repaint from", (new Error()).stack.split("\n")[2].trim().split(" ")[1], dontUpdateStatusToIdle);
    doDraw();
    let rpsText = rowsPerSecond.toPrecision(3) + " rows per second";
    if (running) {
        repaintTimeout = setTimeout(repaint, repaintTimer);
        let rc = rowsCompleted;
        let pass = "";
        let ch = canvas.height;
        if (state == COMPUTING_SECOND_PASS) {
            rc -= ch;
            ch += 1;
            pass = " second pass";
        }
        let prec = highPrecision ? "high precision, " + digits + " digits" : "normal precision";
        document.getElementById("status").innerHTML =
                    "Computing" + pass + ", " + prec +
                    "...  Completed " + rc + " of " + ch + " rows at " + rpsText;
    }
    else if (dontUpdateStatusToIdle !== true) {
        document.getElementById("status").innerHTML = "Idle (" + rpsText + ")";
    }
}

const jsRemoteWorker = "mandelbrot-worker-remote-v2.0.js"
const jsLocalWorker = "mandelbrot-worker-local-wasm.js"
function newWorkers(count) {
    // console.log("newWorkers from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (workers) {
       for (let i = 0; i < workers.length; i++) {
          workers[i].terminate();
       }
    }
    workers = [];
    let jsWorker = document.getElementById("local").checked ? jsLocalWorker : jsRemoteWorker;
    for (let i = 0; i < count; i++) {
        workers[i] = new Worker(jsWorker);
        workers[i].onmessage = jobFinished;
        workers[i].postMessage([ "wasm", i, compute_mandelbrot ]);
    }
}

function stopJob(dontUpdateStatusToIdle) {
    // console.log("stopJob", running, "from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (running) {
        jobNum++;
        running = false;
        document.getElementById("stop").disabled = true;
        if (repaintTimeout) {
            clearTimeout(repaintTimeout);
            repaintTimeout = null;
        }
        repaint(dontUpdateStatusToIdle);
        if (highestJobNumFinished < jobNum - 1) {///??? not sufficient, long waits
            // let timeSinceStart = Date.now() - jobStartTime;
            // console.log("Making new workers - highestJobNumFinished =", highestJobNumFinished, "jobNum =", jobNum, "after", timeSinceStart, "ms");
            newWorkers(workerCount);
        }
    }
}

let maxRowsPerJob = 32;
let maxRowsPerJobHP = 4;

function startJob(dontClear) {
    // console.log("startJob",zoomTimeout != null,running, "from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (running) {
       stopJob();
    }
    if (! zoomTimeout && dontClear !== true) {
        graphics.fillStyle = "#BBBBBB";
        graphics.fillRect(0,0,canvas.width,canvas.height);
        OSG.fillStyle = "#BBBBBB";
        OSG.fillRect(0,0,canvas.width,canvas.height);
    }
    imageData = OSG.getImageData(0,0,canvas.width,1);
    hres = Math.round(imageData.width/canvas.width);
    vres = imageData.height;
    dx = xmax.subtract(xmin).divide(new BigDecimal(""+(canvas.width-1)),BigDecimal.ROUND_HALF_EVEN);
    dy = ymax.subtract(ymin).divide(new BigDecimal(""+(canvas.height-1)),BigDecimal.ROUND_HALF_EVEN);
    highPrecision = document.getElementById("highPrecision").checked || dy.compareTo(HP_CUTOFF) < 0;
    jobs = [];
    var yVal = ymax.add(new BigDecimal("0"));
    var rows = canvas.height;
    var columns = canvas.width;
    savedIterationCounts = new Array(rows);
    savedIterationCounts2ndPass = new Array(rows+1);
    if (highPrecision) {
        digits = xmin.scale();
        chunks = Math.floor((digits * log2of10)/16 + 2);
        xminArray = new ArrayType(chunks+1);
        dxArray = new ArrayType(chunks+1);
        let dyArray = new ArrayType(chunks+1);
        convert(xminArray, xmin, chunks+1);
        convert(dxArray,dx,chunks+1);
        convert(dyArray, dy, chunks+1);

        let rowsPerJobHP = Math.min(maxRowsPerJobHP, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJobHP) {
            let ytmp = yVal.subtract(dy.multiply(new BigDecimal(row.toString())));
            yValArray = new ArrayType(chunks+1);
            convert(yValArray, ytmp, chunks+1);
            jobs.push({
                row: row,
                columns: columns,
                xmin: xminArray,
                dx: dxArray,
                yVal: yValArray,
                dy: dyArray,
                nrows: Math.min(rowsPerJobHP, rows - row)
            });
        }
    }
    else {
        var xmin_d = Number(xmin.toString());
        var yVal_d = Number(yVal.toString());
        var dx_d = Number(dx.toString());
        var dy_d = Number(dy.toString());
        // console.log(dx_d, dy_d, xmin_d, yVal_d);

        let rowsPerJob = Math.min(maxRowsPerJob, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJob) {
            jobs.push({
                row: row,
                columns: columns,
                xmin: xmin_d,
                dx: dx_d,
                yVal: yVal_d,   // to reduce error calculate y in worker as yVal_d - (row + 0..nrows)*dy_d
                dy: dy_d,
                nrows: Math.min(rowsPerJob, rows - row)
            });
        }
    }
    jobs.reverse();     // keep original order

    if (interlaced) {
        var sortedJobs = jobs;
        jobs = [];
        for (var i = 0; i < interlaceOrder.length; i++) {
            for (var j = interlaceOrder[i]; j < sortedJobs.length; j += interlaceOrder.length) {
                jobs.push(sortedJobs[j]);
                //if (sortedJobs[j] == null) {  // for debugging
                //    throw "bad logic";
                //}
                //sortedJobs[j] = null;
            }
        }
    }

    jobStartTime = Date.now();
    for (let i = 0; i < workerCount; i++) {
        let j = jobs.pop();
        j.workerNum = i;
        workers[i].postMessage(["setup",jobNum, maxIterSlider.value,highPrecision,i]);
        workers[i].postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }

    rowsCompleted = 0;
    rowsPerSecond = 0;
    running = true;
    document.getElementById("stop").disabled = false;
    var prec = highPrecision ? "high precision, " + digits + " digits" : "normal precision";
    document.getElementById("status").innerHTML = "Computing, " + prec + "...";
    if (! zoomTimeout) {
        repaintTimeout = setTimeout(repaint, repaintInitialTimer);
    }
    state = COMPUTING_FIRST_PASS;
    currentXML = currentExampletoXML();
}

function jobFinished(msg) {
    var job = msg.data;
    highestJobNumFinished = Math.max(highestJobNumFinished, job[0]);
    if (job[0] != jobNum)
       return;
    if (jobs.length > 0) {
       var worker = workers[job[3]];
       var j = jobs.pop();
       worker.postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }
    var iterationCounts = job[2];
    let nRows = job[4];
    for (let i = 0; i < nRows; i++) {
        let row = job[1] + i;
        if (state == COMPUTING_FIRST_PASS) {
           savedIterationCounts[row] = iterationCounts[i];
           putRow(row);
        }
        else {
            savedIterationCounts2ndPass[row] = iterationCounts[i];
            // all rows need to be present for averaging second pass if workerCount > 1
            //if (row > 0) {
            //   putRow(row-1);
            //}
        }
    }
    rowsCompleted += nRows;
    rowsPerSecond = rowsCompleted/((Date.now() - jobStartTime)/1000.0);
    if (state == COMPUTING_FIRST_PASS) {
        if (rowsCompleted == canvas.height) {
            state = DONE_FIRST_PASS;
            if (document.getElementById("secondpass").checked) {
                stopJob(true);
                startSecondPass();
            } else {
                stopJob();
            }
       }
    }
    else {
        if (rowsCompleted == 2*canvas.height + 1) {
            // all rows need to be present for averaging second pass if workerCount > 1
            for (let row = 0; row < canvas.height; row++) {
                putRow(row);
            }
            state = IDLE;
            stopJob();
        }
    }
}

function startSecondPass() {
    if (running) {
       stopJob();
    }
    dx = xmax.subtract(xmin).divide(new BigDecimal(""+(canvas.width-1)),BigDecimal.ROUND_HALF_EVEN);
    dy = ymax.subtract(ymin).divide(new BigDecimal(""+(canvas.height-1)),BigDecimal.ROUND_HALF_EVEN);
    var dxHalf = dx.divide(TWO,BigDecimal.ROUND_HALF_EVEN);
    var dyHalf = dy.divide(TWO,BigDecimal.ROUND_HALF_EVEN);
    highPrecision = document.getElementById("highPrecision").checked || dy.compareTo(HP_CUTOFF) < 0;
    jobs = [];
    var yVal = ymax.add(dyHalf);
    var xStart = xmin.subtract(dxHalf);
    var rows = canvas.height + 1;
    var columns = canvas.width + 1;
    if (highPrecision) {
        digits = xmin.scale();
        chunks = Math.floor((digits * log2of10)/16 + 2);
        xminArray = new ArrayType(chunks+1);
        dxArray = new ArrayType(chunks+1);
        let dyArray = new ArrayType(chunks+1);
        convert(xminArray, xStart, chunks+1);
        convert(dxArray,dx,chunks+1);
        convert(dyArray, dy, chunks+1);

        let rowsPerJobHP = Math.min(maxRowsPerJobHP, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJobHP) {
            let ytmp = yVal.subtract(dy.multiply(new BigDecimal(row.toString())));
            yValArray = new ArrayType(chunks+1);
            convert(yValArray, ytmp, chunks+1);
            jobs.push({
                row: row,
                columns: columns,
                xmin: xminArray,
                dx: dxArray,
                yVal: yValArray,
                dy: dyArray,
                nrows: Math.min(rowsPerJobHP, rows - row)
            });
        }
    }
    else {
        var xmin_d = Number(xStart.toString());
        var yVal_d = Number(yVal.toString());
        var dx_d = Number(dx.toString());
        var dy_d = Number(dy.toString());
        //var ymax_d = Number(ymax.toString()) + dy_d/2;

        let rowsPerJob = Math.min(maxRowsPerJob, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJob) {
            jobs.push({
                row: row,
                columns: columns,
                xmin: xmin_d,
                dx: dx_d,
                yVal: yVal_d,   // to reduce error calculate y in worker as yVal_d - (row + 0..nrows)*dy_d
                dy: dy_d,
                nrows: Math.min(rowsPerJob, rows - row)
            });
        }
        //jobs.reverse();     // keep original order (don't need to since now we're waiting for all rows to finish before drawing)
    }
    for (var i = 0; i < workerCount; i++) {
        var j = jobs.pop();
        j.workerNum = i;
        workers[i].postMessage(["setup",jobNum, maxIterSlider.value,highPrecision,i]);
        workers[i].postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }
    running = true;
    document.getElementById("stop").disabled = false;
    repaintTimeout = setTimeout(repaint, repaintInitialTimer);
    state = COMPUTING_SECOND_PASS;
}

function putRow(row) {
    var iterationCounts = savedIterationCounts[row];
    var above = savedIterationCounts2ndPass[row];
    var below = savedIterationCounts2ndPass[row+1];
    var average = above && below;
    var secondPassColor;
    var ct;
    if (average) {
       ct = above[0];
       var c1 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
       ct = below[0];
       var c2 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
       secondPassColor = [c1[0]+c2[0],c1[1]+c2[1],c1[2]+c2[2]];
    }
    var columns = canvas.width;
    for (var i = 0; i < columns; i++) {
       ct = iterationCounts[i];
       var color;
       if (ct < 0) {
          color = [0,0,0];
       }
       else {
          var paletteIndex = iterationCounts[i] % paletteLength;
          color = paletteColors[paletteIndex];
       }
       if (average) {
           ct = above[i+1];
           var c1 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
           ct = below[i+1];
           var c2 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
           var secondPassColor2 = [c1[0]+c2[0],c1[1]+c2[1],c1[2]+c2[2]];
           color = [ // had a bug where I modified the color that was still in the palette array!
               ( 4*color[0] + secondPassColor[0] + secondPassColor2[0] ) / 8,
               ( 4*color[1] + secondPassColor[1] + secondPassColor2[1] ) / 8,
               ( 4*color[2] + secondPassColor[2] + secondPassColor2[2] ) / 8
           ];
           secondPassColor = secondPassColor2;
       }
       var p = 4*i*hres;
       for (var j = 0; j < hres; j++) {
           imageData.data[p] = color[0];
           imageData.data[p+1] = color[1];
           imageData.data[p+2] = color[2];
           imageData.data[p+3] = 255;
       }
    }
    for (var i = 0; i < vres; i++) {
        OSG.putImageData(imageData,0,row*vres+i);
    }
}

function setDefaults() {
    let oldXML = currentXML;
    let oldPaletteSelectSliderState = paletteSelectSlider.getPaletteSelectSliderState();
    stopJob();
    setLimits(new BigDecimal("-2.2"), new BigDecimal("0.8"), new BigDecimal("-1.2"), new BigDecimal("1.2"), false);
    maxIterSlider.setDefault();
    mainPaletteLengthSlider.setDefaultsFromMaxIter();
    fixedPaletteLength = mainPaletteLengthSlider.value;
    mainPaletteOffsetSlider.setDefault();
    paletteSelectSlider.reset();
    palette = new Palette();
    createPaletteColors();
    document.getElementById("customsize").style.display = "none";
    document.getElementById("imagesize").value = "0 0";
    setCanvasToWindow();
    startJob();
    if (undoList) {
        addUndoItem("Restore Defaults", [oldXML, oldPaletteSelectSliderState],
            [currentXML, paletteSelectSlider.getPaletteSelectSliderState()]);
    }
}

function remapColors() {
    for (var row = 0; row < canvas.height; row++) {
       if (savedIterationCounts[row]) {
           putRow(row);
       }
    }
    doDraw();
    currentXML = currentExampletoXML();
}

function createPaletteColors(newPaletteOffset) {
    paletteLength = fixedPaletteLength;
    let offset = typeof newPaletteOffset === "number" ? newPaletteOffset/100 : mainPaletteOffsetSlider.value/100;
    offset = Math.round(offset * paletteLength);
    paletteColors = palette.makeRGBs(paletteLength,offset);
}

const ZOOM = 1;
const ZOOMINRECT = 2;
const ZOOMOUTRECT = 3;

function DragBox(x,y) {
    this.x = this.left = x;
    this.y = this.top = y;
    this.width = 0;
    this.height = 0;
}
DragBox.prototype.draw = function() {  // Draw the box on the on-screen canvas
    graphics.strokeStyle = "#FFFFFF";
    graphics.lineWidth = 4;
    graphics.strokeRect(this.left,this.top,this.width,this.height);
    graphics.strokeStyle = "#000000";
    graphics.lineWidth = 2;
    graphics.strokeRect(this.left,this.top,this.width,this.height);
}
DragBox.prototype.setCorner = function(x1,y1) {
    var w = Math.abs(x1 - this.x);
    var h = Math.abs(y1 - this.y);
    if (w < 3 || h < 3) {
        this.width = this.height = 0;
        return;
    }
    var aspect = canvas.width/canvas.height;
    var rectAspect = w / h;
    if (aspect > rectAspect)
        w = Math.round(w*aspect/rectAspect);
    else if (aspect < rectAspect)
        h = Math.round(h*rectAspect/aspect);
    if (this.x < x1) {
        this.left = this.x;
    }
    else {
        this.left = this.x - w;
    }
    if (this.y < y1) {
        this.top = this.y;
    }
    else {
        this.top = this.y - h;
    }
    this.width = w;
    this.height = h;
}
DragBox.prototype.zoom = function(zoomin) {
    if (this.width <= 2 || this.height <= 2)
       return;
    stopJob();
    if (zoomin == false) {
        doZoomOutFromRect(this.left, this.top, this.width, this.height, true);
    }
    else {
        doZoomInOnRect(this.left, this.top, this.width, this.height, true);
    }
    startJob();
}

var zoomTimeout;
var OSZC;  // Zoom canvas.
var OSZG;  // Graphics context for zoom canvas.
const FPS = 60;
const ZOOMTIME = 250;   // zoom time in ms
const NFRAMES = Math.floor(ZOOMTIME/1000*FPS);
const FRAMEINTERVAL = ZOOMTIME/NFRAMES;

function drawZoom(left, top, width, height) {
    // console.log("drawZoom from", (new Error()).stack.split("\n")[2].trim().split(" ")[1], left, top, width, height, NFRAMES, FRAMEINTERVAL);

    // draw latest OSC
    graphics.drawImage(OSC,0,0);

    // scale image into OSG with gray surround if needed
    OSG.fillStyle = "#BBBBBB";
    OSG.fillRect(0, 0, canvas.width, canvas.height);
    OSG.drawImage(canvas, left, top, width, height, 0, 0, canvas.width, canvas.height);

    // save the un-zoomed image
    if (! OSZC) {
        OSZC = document.createElement("canvas");
        OSZG = OSZC.getContext("2d");
    }
    OSZC.width = canvas.width;
    OSZC.height = canvas.height;
    OSZG.drawImage(canvas, 0, 0);

    let frameCount = 1;
    zoomDrawFrame(left, top, width, height, frameCount);
    frameCount++;
    zoomTimeout = setInterval(function () {
        if (frameCount < NFRAMES) {
            zoomDrawFrame(left, top, width, height, frameCount);
            frameCount++;
        } else {
            clearInterval(zoomTimeout);
            zoomTimeout = null;
            repaint();
        }
    }, FRAMEINTERVAL);
}

function zoomDrawFrame(left, top, width, height, frameCount) {
    const zoomFactor = frameCount/NFRAMES;
    const leftZ = left*zoomFactor;
    const topZ = top*zoomFactor;
    const widthZ = canvas.width - (canvas.width - width)*zoomFactor;
    const heightZ = canvas.height - (canvas.height - height)*zoomFactor;
    graphics.fillStyle = "#BBBBBB";
    graphics.fillRect(0,0,canvas.width,canvas.height);
    graphics.drawImage(OSZC, leftZ, topZ, widthZ, heightZ, 0, 0, canvas.width, canvas.height);
}

function doZoomInOnRect(x,y,width,height,undo) {
    // console.log("doZoomInOnRect", x, y, width, height);
    var rectX = new BigDecimal("" + Math.round(x));  // (Firefox can have fractional parts)
    var rectY = new BigDecimal("" + Math.round(y));
    var rectW = new BigDecimal("" + Math.round(width));
    var rectH = new BigDecimal("" + Math.round(height));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var pixelWidth = xmax.subtract(xmin).divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN);
    var pixelHeight = ymax.subtract(ymin).divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN);
    var newXmin,newXmax,newYmin,newYmax;
    newXmin = xmin.add(pixelWidth.multiply(rectX));
    newYmax = ymax.subtract(pixelHeight.multiply(rectY));
    var newWidth = pixelWidth.multiply(rectW);
    var newHeight = pixelHeight.multiply(rectH);
    newXmax = newXmin.add(newWidth);
    newYmin = newYmax.subtract(newHeight);
    setLimits(newXmin, newXmax, newYmin, newYmax, false);
    if (undo) {
        addUndoItem("Zoom In", [ZOOMOUTRECT, x, y, width, height], [ZOOMINRECT, x, y, width, height]);
    }
    drawZoom(x, y, width, height);
}

function doZoomOutFromRect(x,y,width,height, undo) {
    // console.log("doZoomOutFromRect", x, y, width, height);
    var rectX = new BigDecimal("" + Math.round(x));
    var rectY = new BigDecimal("" + Math.round(y));
    var rectW = new BigDecimal("" + Math.round(width));
    var rectH = new BigDecimal("" + Math.round(height));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var newPixelWidth = xmax.subtract(xmin).divide(rectW,BigDecimal.ROUND_HALF_EVEN);
    var newPixelHeight = ymax.subtract(ymin).divide(rectH,BigDecimal.ROUND_HALF_EVEN);
    var newXmin,newXmax,newYmin,newYmax;
    newXmin = xmin.subtract(newPixelWidth.multiply(rectX));
    newYmax = ymax.add(newPixelHeight.multiply(rectY));
    var newWidth = newPixelWidth.multiply(ImageWidth);
    var newHeight = newPixelHeight.multiply(ImageHeight);
    newXmax = newXmin.add(newWidth);
    newYmin = newYmax.subtract(newHeight);
    setLimits(newXmin, newXmax, newYmin, newYmax, false);
    if (undo) {
        addUndoItem("Zoom Out", [ZOOMINRECT, x, y, width, height], [ZOOMOUTRECT, x, y, width, height]);
    }

    let zoomFactor = (canvas.width/width + canvas.height/height)/2;
    drawZoom(-zoomFactor*x, -zoomFactor*y, zoomFactor*canvas.width, zoomFactor*canvas.height);
}

function zoom(x, y, zoomFactor, recenter, undo) {  // (x,y) is center of zoom, in pizels; recenter moves that point to center of image
    // console.log("zoom:", x, y, zoomFactor, recenter);
    stopJob();
    var zf = new BigDecimal("" + zoomFactor);
    var X = new BigDecimal("" + Math.round(x));
    var Y = new BigDecimal("" + Math.round(y));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var oldWidth = xmax.subtract(xmin);
    var oldHeight = ymax.subtract(ymin);
    var newWidth = oldWidth.multiply(zf);
    var newHeight = oldHeight.multiply(zf);
    if (newWidth.compareTo(new BigDecimal("100")) > 0) {
        document.getElementById("status").innerHTML =
            "Zooming out that far would reduce the whole Mandelbrot set to a dot.  Ignored.";
        return;
    }
    var pixelWidth = newWidth.divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN);
    var pixelHeight = newHeight.divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN);
    var centerX = xmin.add(X.multiply(oldWidth).divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN));
    var centerY = ymax.subtract(Y.multiply(oldHeight).divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN));
    var newXmin,newXmax,newYmin,newYmax;
    if (recenter) {
        newXmin = centerX.subtract(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN));
        newYmax = centerY.add(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN));
    }
    else {
        newXmin = centerX.subtract(X.multiply(pixelWidth));
        newYmax = centerY.add(Y.multiply(pixelHeight));
    }
    newYmin = newYmax.subtract(newHeight);
    newXmax = newXmin.add(newWidth);
    setLimits(newXmin, newXmax, newYmin, newYmax, false);

    if (undo) {
        let midX = canvas.width/2;
        let midY = canvas.height/2;
        let undoLabel = zoomFactor > 1 ? "Zoom Out" : "Zoom In";
        let newZoom = [ZOOM, x, y, zoomFactor, recenter];
        if (recenter) {
            addUndoItem(undoLabel, [ZOOM, midX + (midX - x)/zoomFactor, midY + (midY - y)/zoomFactor, 1/zoomFactor, recenter], newZoom);
        } else {
            addUndoItem(undoLabel, [ZOOM, x, y, 1/zoomFactor, recenter], newZoom);
        }
    }

    let width = canvas.width*zoomFactor;
    let height = canvas.height*zoomFactor;
    let left, top;
    if (recenter) {
        left = x - width/2;
        top = y - height/2;
    } else {
        left = x*(1 - zoomFactor);
        top = y*(1 - zoomFactor);
    }
    drawZoom(left, top, width, height);
    startJob();
}


function setUpDragging() {  // for image canvas
    var zoomin;
    var startX, startY; // for mouse only
    dragbox = null;  // initially, the mouse is not being dragged.
    canvas.addEventListener("dblclick",doMouseDoubleClick,false);
    new Mouser(canvas, startDrag, continueDrag, endDrag, true);
    function startDrag(x,y,evt) {
        if (evt && evt.button != 0)  // only allow left button to start drag
            return false;
        startX = x;
        startY = y;
        dragbox = null;
        zoomin = ! (evt && evt.shiftKey); 
        return true;
    }
    function continueDrag(x,y) {  
        if (dragbox == null) {
            if ( Math.abs(startX - x) < 3 && Math.abs(startY - y) < 3) {
                return;  // don't show zoombox until mouse/touch has moved a bit.
            }
            dragbox = new DragBox(startX,startY);
        }
        dragbox.setCorner(x,y);
        doDraw();
    }
    function endDrag() {
        if (dragbox != null) {
            doDraw();
            dragbox.zoom(zoomin);
            dragbox = null;
        }
    }
    function doMouseDoubleClick(evt) { 
        if (dragbox || evt.button != 0) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;
        var zoomFactor = evt.shiftKey? 2 : 0.5;
        zoom(x,y,zoomFactor,!evt.altKey && !evt.ctrlKey, true);
    }
 }

function Mouser(canvas, startDrag, continueDrag, endDrag, mouseMoveOnCanvasOnly) {
      // functions startDrag, continueDrag take canvas coords (x,y); for a mouse event event object is also passed.
      // function endDrag takes no parameter for touched, mouse event for mouse actions.
      // function startDrag returns a boolean, true if the down action should start a drag.
    var dragging = false;
    canvas.addEventListener("mousedown",doMouseDown,false);
    canvas.addEventListener("touchstart",doTouchStart,false);
    function doMouseDown(evt) { 
        if (dragging) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;
        if (startDrag(x,y,evt)) {
            dragging = true;
            (mouseMoveOnCanvasOnly? canvas : document).addEventListener("mousemove",doMouseMove,false);
            document.addEventListener("mouseup",doMouseUp,false);
        }
    }
    function doMouseMove(evt) {
        if (!dragging) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;
        continueDrag(x,y,evt); 
    }
    function doMouseUp(evt) {
        if (dragging) {  
            dragging = false;
            (mouseMoveOnCanvasOnly? canvas : document).removeEventListener("mousemove",doMouseMove,false);
            document.removeEventListener("mouseup",doMouseUp,false);
            endDrag(evt);
        }
    }
    function doTouchStart(evt){
        if (evt.touches.length != 1) {
           doTouchCancel();
           return;
        }
        evt.preventDefault();
        if (dragging) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.touches[0].clientX - r.left;
        var y = evt.touches[0].clientY - r.top;
        if (startDrag(x,y)) {
            dragging = true;
            canvas.addEventListener("touchmove", doTouchMove);
            canvas.addEventListener("touchend", doTouchEnd);
            canvas.addEventListener("touchcancel", doTouchCancel);
        }
    }
    function doTouchMove(evt){
        if (!dragging)
           return;
        evt.preventDefault();
        if (evt.touches.length != 1) {
           doTouchCancel();
           return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.touches[0].clientX - r.left;
        var y = evt.touches[0].clientY - r.top;
        continueDrag(x,y);
    }
    function doTouchEnd(evt) {
        doTouchCancel();
    }
    function doTouchCancel() {
        if (dragging) {
           canvas.removeEventListener("touchmove", doTouchMove);
           canvas.removeEventListener("touchend", doTouchEnd);
           canvas.removeEventListener("touchcancel", doTouchCancel);
           endDrag();
           dragging = false;
        }
    }
}

function changeWorkerCount() {
    var ct = Number(document.getElementById("threadCountSelect").value);
    if (workers && ct == workers.length)
        return;
    var restart  = running;
    if (running) {
        stopJob();
    }
    workerCount = ct;
    newWorkers(ct);
    if (restart) {
        startJob();
    }
    try {
        localStorage.setItem("mandelbrotWorkerCount" + (document.getElementById("local").checked ? "local" : "remote"), "" + ct);
        // console.log("workers set " + (document.getElementById("local").checked ? "local" : "remote") + " " + ct);
    }
    catch(e) {
    }
}

async function pageExists(url) {
    try {
        const response = await fetch(url);
        // console.log(response);
        return response.ok;
    } catch (error) {
        return false;
    }
}

function initLocalOrRemote() {
    try {
        let item = localStorage.getItem("mandelbrotLocalOrRemote");
        if (item == "local") {
            document.getElementById("local").checked = true;
        } else {
            document.getElementById("remote").checked = true;
        }
    }
    catch(e) {
        document.getElementById("remote").checked = true;
    }
}

function checkRemoteCanComputeMB() {
    pageExists("/remoteCanComputeMB").then(result => {
        if (! result) {
            document.getElementById("remote").disabled = true;
            document.getElementById("localRemote").title = "Mandelbrot web server is not available, calculations will be done in the browser.";
            console.warn("remote web server does not support Mandelbrot calculations");
            if (document.getElementById("remote").checked) {
                document.getElementById("local").checked = true;
                changeLocalOrRemote();
            }
        }
    });
}

function changeLocalOrRemote() {
    let newWorkerCount = workerCount;
    let localOrRemote = document.getElementById("local").checked ? "local" : "remote";
    try {
        localStorage.setItem("mandelbrotLocalOrRemote", localOrRemote);
        let ct = Number(localStorage.getItem("mandelbrotWorkerCount" + localOrRemote));
        // console.log("workers get " + (document.getElementById("local").checked ? "local" : "remote") + " " + ct);
        if (! isNaN(ct) && ct > 0) {
            newWorkerCount = ct;
        }
    }
    catch(e) {
    }
    if (running) {
        stopJob();
        workerCount = newWorkerCount;
        newWorkers(workerCount);
        startJob();
    } else {
        workerCount = newWorkerCount;
        newWorkers(workerCount);
    }
    document.getElementById("threadCountSelect").value = "" + newWorkerCount;
}

function setMaxIterations() {
    stopJob();
    createPaletteColors();
    startJob(true);
}

function setFixedPaletteLength(newPaletteLength) {
    // console.log("setFixedPaletteLength:", newPaletteLength);
    fixedPaletteLength = newPaletteLength;
    createPaletteColors();
    remapColors();
}

function doPaletteOffset(newPaletteOffset) {
    createPaletteColors(newPaletteOffset);
    remapColors();
}
function finishDoPaletteOffset(newPaletteOffset, oldPaletteState) {
    currentXML = currentExampletoXML();
    addUndoItem("Change PaletteOffset", oldPaletteState.value/100, newPaletteOffset/100);
}

function changeInterlaced() {
   var checked = document.getElementById("interlaced").checked;
   if (checked == interlaced) {
       return;
   }
   interlaced = checked;
   if (running) {
       stopJob();
       startJob();
   }
}

function changeImageSize() {
    var val = document.getElementById("imagesize").value;
    if (val === "Custom") {
        document.getElementById("customwidth").value = "" + canvas.width;
        document.getElementById("customheight").value = "" + canvas.height;
        document.getElementById("customsize").style.display = "inline";
    } else if (val === "0 0") {
        document.getElementById("customsize").style.display = "none";
        setImageSizeToWindow(true);
    } else {
        document.getElementById("customsize").style.display = "none";
        var sizes = val.split(" ");
        var width = Number(sizes[0]);
        var height = Number(sizes[1]);
        setImageSizeToFixed(width,height,true);
    }
}
function setImageSizeToFixed(w,h,undo) {
    if (w == canvas.width && h == canvas.height) {
        return;
    }
    let oldval = fitWindow ? [0, 0] : [canvas.width, canvas.height];
    fitWindow = false;
    stopJob();
    canvas.width = w;
    canvas.height = h;
    OSC.width = w;
    OSC.height = h;
    checkAspect();
    startJob();
    if (undo) {
        addUndoItem("Change Image Size", oldval, [canvas.width,canvas.height]);
    }
}
function doCustomSize() {
    var width = Math.round(Number(document.getElementById("customwidth").value.trim()));
    var height = Math.round(Number(document.getElementById("customheight").value.trim()));
    if (isNaN(width) || width < 64 || width > 7680) {
        document.getElementById("status").innerHTML = "Illegal value for image width.  Must be an integer in the range 64 to 7680.";
        return;
    }
    if (isNaN(height) || height < 64 || height > 7680) {
        document.getElementById("status").innerHTML = "Illegal value for image height.  Must be an integer in the range 64 to 7680.";
        return;
    }
    setImageSizeToFixed(width,height,true);
}
function setCanvasToWindow() {
    let w = Math.max(64, window.innerWidth - 275);
    let h = Math.max(64, window.innerHeight - 100);
    if (canvas.width != w || canvas.height != h) {
      canvas.width = w;
      canvas.height = h;
      OSC.width = w;
      OSC.height = h;
      checkAspect();
    }
    fitWindow = true;
}
function setImageSizeToWindow(undo) {
    let w = window.innerwidth - 200;
    let h = window.innerHeight - 100;
    if (w == canvas.width && h == canvas.height) {
        return;
    }
    let oldval = fitWindow ? [0, 0] : [canvas.width, canvas.height];
    stopJob();
    setCanvasToWindow();
    startJob();
    if (undo) {
        addUndoItem("Change Image Size", oldval, [0, 0]);
    }
}
function resizeFitWindow() {
    if (! fullScreenCanvas && ! fullWindowCanvas) {
        // console.log("resizeFitWindow");
        if (fitWindow) {
            setImageSizeToWindow(false);
        }
        setTooltipSize();
    }
}
function setImageSize(w, h, undo) {
    if (fitWindow) {
        setImageSizeToWindow(undo);
    } else {
        setImageSizeToFixed(w, h, undo);
    }
}
function setTooltipSize() {
    const w = window.innerWidth;
    // console.log(w);
    let tooltip = document.querySelector('.tooltip .helptext');
    tooltip.style.width = Math.min(800, w*0.8) + "px";

    tooltip = document.querySelector('.tooltip .exampletext');
    if (w < 475) {
        tooltip.style.width = Math.min(800, w*0.65) + "px";
    } else {
        tooltip.style.width = Math.min(800, w*0.75) + "px";
    }
}

function doApplyStandardPalette(newPaletteNum, newPalette) {
    if (newPalette) {
        palette = newPalette;
    } else {
        let name = paletteSelectSlider.paletteName(newPaletteNum);
        palette = Palette.createStandardPalette(name);
    }
    createPaletteColors();
    remapColors();
}

function changeSecondPass() {
    var checked = document.getElementById("secondpass").checked;
    if (checked && !running && state == DONE_FIRST_PASS) {
        startSecondPass();
    }
}

function changeHighPrecision() {
    var checked = document.getElementById("highPrecision").checked;
    if (running && checked != highPrecision) {
        stopJob();
        startJob();
    }
}

function doZoomIn(z) {
    zoom(canvas.width/2, canvas.height/2, 1/z, false, true);
}

function doZoomOut(z) {
    zoom(canvas.width/2, canvas.height/2, z, false, true);
}

//---------------------- Undo/Redo ---------------------------------------

function doUndo() {
    if (undoCount > 0) {
        var item = undoList[undoCount-1];
        undoCount--;
        document.getElementById("undo").disabled = (undoCount == 0);
        document.getElementById("undo").innerHTML = undoCount? ("Undo " + undoList[undoCount-1].name) : "Undo";
        document.getElementById("redo").disabled = false;
        document.getElementById("redo").innerHTML = "Redo " + item.name;
        applyUndoItem(item.name, item.oldValue);
    }
}

function doRedo() {
    if (undoCount < undoList.length) {
        var item = undoList[undoCount];
        undoCount++;
        document.getElementById("undo").disabled = false;
        document.getElementById("undo").innerHTML = "Undo " + item.name;
        document.getElementById("redo").disabled = (undoCount == undoList.length);
        document.getElementById("redo").innerHTML = (undoCount < undoList.length)? ("Redo " + undoList[undoCount].name) : "Redo";
        applyUndoItem(item.name, item.newValue);
    }
}

function addUndoItem(name, oldValue, newValue) {
    if (applyUndoInProgress) {
        return;
    }
    undoList.length = undoCount;
    undoList.push( { name: name, oldValue: oldValue, newValue: newValue } );
    if (undoList.length > 100) {
        undoList.shift();
    }
    undoCount = undoList.length;
    document.getElementById("undo").disabled = false;
    document.getElementById("undo").innerHTML = "Undo " + name;
    document.getElementById("redo").disabled = true;
    document.getElementById("redo").innerHTML = "Redo";
}

function applyUndoItem(name, value) {
    applyUndoInProgress = true;
    switch (name) {
      case "Restore Defaults":
      case "Import Example":
          installExampleFromXML(value[0],false,true);
          paletteSelectSlider.setPaletteSelectSliderState(value[1]);
          break;
      case "Change PaletteOffset":
         mainPaletteOffsetSlider.setValue(value*100);
         doPaletteOffset();
         break;
      case "Change Limits":
         stopJob();
         setLimits(value[0],value[1],value[2],value[3],false);
         startJob();
         break;
      case "Change Image Size":
        var val = value[0] + " " + value[1];
        if (val === "0 0") {
            setImageSizeToWindow(false);
        } else {
            setImageSizeToFixed(value[0],value[1],false);
        }
         if (! fitWindow && ["640 480", "800 600", "1024 768", "1600 1200", "1920 1080", "1920 1200", "2560 1440", "2880 1800", "3840 1080", "3840 2160", "5120 1440", "7680 4320"].indexOf(val) < 0) {
             document.getElementById("imagesize").value = "Custom";
             document.getElementById("customsize").style.display = "inline";
             document.getElementById("customwidth").value = "" + value[0];
             document.getElementById("customheight").value = "" + value[1];
         }
         else {
             document.getElementById("imagesize").value = fitWindow ? "0 0" : val;
             document.getElementById("customsize").style.display = "none";
         }
         break;
      case "Change PaletteLength":
        mainPaletteLengthSlider.setState(value);
        setFixedPaletteLength(mainPaletteLengthSlider.value);
        break;
      case "Change MaxIterations":
         maxIterSlider.setValue(value[0]);
         setMaxIterations();
         mainPaletteLengthSlider.setState(value[1]);
         setFixedPaletteLength(mainPaletteLengthSlider.value);
         break;
      case "Change Palette":
         palette = value[0].copy();
         paletteSelectSlider.setValue(value[1]);
         createPaletteColors();
         remapColors();
         break;
      case "Edit Palette":
        palette = value[0].copy();
        mainPaletteOffsetSlider.setValue(value[2]*100);
        paletteSelectSlider.setPaletteSelectSliderState(value[3]);
        mainPaletteLengthSlider.setValue(value[1]);
        setFixedPaletteLength(mainPaletteLengthSlider.value);
        break;
      case "Zoom Out":
      case "Zoom In":
        // console.log(value);
        switch (value[0]) {
            case ZOOM:
                zoom(value[1], value[2], value[3], value[4], false);
                break;
            case ZOOMINRECT:
                stopJob();
                doZoomInOnRect(value[1], value[2], value[3], value[4], false);
                startJob();
                break;
            case ZOOMOUTRECT:
                stopJob();
                doZoomOutFromRect(value[1], value[2], value[3], value[4], false);
                startJob();
                break;
        }
        break;
    }
    applyUndoInProgress = false;
}

//--------------------- Palette ------------------------------------------
function Palette(colorType,divisionPoints,colors) {
   this.colorType = colorType || "HSB";
   this.divisionPoints = divisionPoints || [0,1];
   this.divisionColors = colors || (this.colorType == "HSB" ? [ [0,1,1], [1,1,1] ] : [ [1,1,1], [0,0,0] ]);
}
Palette.prototype.getColor = function(position) {  // 0.0 <= position <= 1.0
    var pt = 1;
    while (position > this.divisionPoints[pt])
        pt++;
    var ratio = (position - this.divisionPoints[pt-1]) /
                   (this.divisionPoints[pt] - this.divisionPoints[pt-1]);
    var c1 = this.divisionColors[pt-1];
    var c2 = this.divisionColors[pt];
    var a = c1[0] + ratio*(c2[0] - c1[0]);
    var b = c1[1] + ratio*(c2[1] - c1[1]);
    var c = c1[2] + ratio*(c2[2] - c1[2]);
    return this.toRGB(a,b,c);
};
Palette.prototype.toRGB = function(a,b,c) {  // 3 non-clamped color components.
    a = (this.colorType == "HSB")? (a - Math.floor(a)) : clamp(a);
    b = clamp(b);
    c = clamp(c);
    var color;
    if (this.colorType == "HSB")
        color = rgbFromHSV(a, b, c);
    else
        color = [a,b,c];
    color[0] = Math.round(color[0]*255);
    color[1] = Math.round(color[1]*255);
    color[2] = Math.round(color[2]*255);
    return color;
	function clamp(x) {
		x = 2*(x/2 - Math.floor(x/2));
		if (x > 1)
			x = 2 - x;
		return x;
	}
    function rgbFromHSV(h,s,v) {  // all components in range 0 to 1
        h *= 360;
        var r,g,b;
        var c,x;
        c = v*s;
        x = (h < 120)? h/60 : (h < 240)? (h-120)/60 : (h-240)/60;
        x = c * (1-Math.abs(x-1));
        x += (v-c);
        switch (Math.floor(h/60)) {
            case 0: r = v; g = x; b = v-c; break;
            case 1: r = x; g = v; b = v-c; break;
            case 2: r = v-c; g = v; b = x; break;
            case 3: r = v-c; g = x; b = v; break;
            case 4: r = x; g = v-c; b = v; break;
            case 5: r = v; g = v-c; b = x; break;
        }
        return [r,g,b];
    }
};
Palette.prototype.makeRGBs = function(paletteLength, offset) {
    var rgb = new Array(paletteLength);
    rgb[offset % paletteLength] =
             this.toRGB(this.divisionColors[0][0],this.divisionColors[0][1],this.divisionColors[0][2]);
    var dx = 1.0 / (paletteLength-1);
    for (var i = 1; i < paletteLength-1; i++) {
        rgb[(offset+i) % paletteLength] = this.getColor(i*dx);
    }
    var last = this.divisionColors.length - 1;
    rgb[(offset+paletteLength-1) % paletteLength] =
              this.toRGB(this.divisionColors[last][0],this.divisionColors[last][1],this.divisionColors[last][2]);
    return rgb;
};
Palette.prototype.makeCanvasColors = function(paletteLength, offset) {
    var rgb = this.makeRGBs(paletteLength,offset);
    var colors = new Array(rgb.length);
    for (var i = 0; i < rgb.length; i++)
        colors[i] = "rgb(" + rgb[i][0] + "," + rgb[i][1] + "," + rgb[i][2] + ")";
    return colors;
};
Palette.prototype.toXMLString = function() {
   var xml = "<palette colorType='" + this.colorType + "'>\n";
   for (var i = 0; i < this.divisionPoints.length; i++) {
       xml += "   <divisionPoint position='" + this.divisionPoints[i] + "' color='" +
            this.divisionColors[i][0] + ";" + this.divisionColors[i][1] + ";" +this.divisionColors[i][2] +
            "'/>\n";
   }
   xml += "</palette>\n";
   return xml;
};
Palette.prototype.copy = function() {
    var divColors = [];
    for (var i = 0; i < this.divisionColors.length; i++) {
        divColors.push(this.divisionColors[i].slice(0));
    }
    return new Palette(this.colorType,this.divisionPoints.slice(0),divColors);
};
Palette.fromXML = function( paletteNode ) {  // can throw an exception
    try {
       var children = paletteNode.childNodes;
       var type = paletteNode.getAttribute("colorType") || "RBG";
       if (type != "HSB" && type != "RGB") {
           throw "Bad colorType.";
       }
       var points = [];
       var colors = [];
       for (var i = 0; i < children.length; i++) {
          var child = children.item(i);
          if (child.nodeType == 1 && child.tagName == "divisionPoint") { // element node
              var pt = child.getAttribute("position");
              var rgb = child.getAttribute("color");
              if (pt === null || rgb === null) {
                  throw "Missing data for divisionPoint";
              }
              pt = Number(pt);
              rgb = rgb.split(";");
              rgb = [Number(rgb[0]),Number(rgb[1]),Number(rgb[2])];
              if (isNaN(pt) || pt < 0 || pt > 1) {
                   throw "Bad data for divisionPoint";
              }
              for (var j = 0; j < 3; j++) {
                   if (isNaN(rgb[j]) || rgb[j] < 0 ){
                      throw "Bad data for divisionPoint color";
                   }
                   else if (rgb[j] < 0) {
                      throw "Color component number " + (j+1) + " can't be less than zero.";
                   }
                   else if (rgb[j] > 1 && (j > 0 || type == "RGB")) {
                      throw "Color component number " + (j+1) + " can't be greater than one.";
                   }
              }
              if (i > 0 && pt <= points[points.length-1]) {
                  throw "Division points out of order";
              }
              points.push(pt);
              colors.push(rgb);
          }
       }
       if (points.length < 2 || points[0] != 0 || points[points.length-1] != 1) {
           throw "Illegal divisionPoint data";
       }
       return new Palette(type, points, colors);
    }
    catch (e) {
        throw "Illegal palette definition: " + e;
    }
};
Palette.createStandardPalette = function(name) {
    var palette;
    switch (name) {
        case "Grayscale":
           palette = new Palette("RGB");
           break;
        case "CyclicGrayscale":
           palette = new Palette("RGB",[0,0.5,1],[[0,0,0],[1,1,1],[0,0,0]]);
           break;
        case "Red/Cyan":
           palette = new Palette("RGB",[0,0.5,1],[[1,0,0],[0,1,1],[1,0,0]]);
           break;
        case "Blue/Gold":
           palette = new Palette("RGB",[0,0.5,1],[[0.1,0.1,1],[1,0.6,0],[0.3,0.3,1]]);
           break;
        case "EarthAndSky":
           palette = new Palette("RGB",[0,0.15,0.33,0.67,0.85,1],
                     [[1,1,1],[1,0.8,0],[0.53,0.12,0.075],[0,0,0.6],[0,0.4,1],[1,1,1]]);
           break;
        case "HotAndCold":
           palette = new Palette("RGB",[0,0.16,0.5,0.84,1],
                     [[1,1,1],[0,0.4,1],[0.2,0.2,0.2],[1,0,0.8],[1,1,1]]);
           break;
        case "Fire":
           palette = new Palette("RGB",[0,0.17,0.83,1],
                     [[0,0,0],[1,0,0],[1,1,0],[1,1,1]]);
           break;
        case "Cyclic Fire":
           palette = new Palette("RGB",[0,0.2,0.4,0.5,0.6,0.8,1],
                     [[0,0,0],[1,0,0],[1,1,0],[1,1,1],[1,1,0],[1,0,0],[0,0,0]]);
           break;
        case "TreeColors":
           palette = new Palette("HSB",[0,0.33,0.66,1],
                     [[0.1266,0.5955,0.2993],[0.0896,0.3566,0.6575],[0.6195,0.8215,0.4039],[0.1266,0.5955,0.2993]]);
           break;
        case "Seashore":
           palette = new Palette("RGB",[0,0.1667,0.3333,0.5,0.6667,0.8333,1],
                     [[0.7909,0.9961,0.7630],[0.8974,0.8953,0.6565],[0.9465,0.3161,0.1267],[0.5184,0.1109,0.0917],
                              [0.0198,0.4563,0.6839],[0.5385,0.8259,0.8177],[0.7909,0.9961,0.7630]]);
           break;
        case "Pastels":
           palette = new Palette("RGB",[0,0.180781,0.418566,0.627035,0.858306,1],
                     [ [ 0.80585,0.81648,0.82180 ], [ 0.43882,0.52393,1 ], [ 1,0.35904,0.58244 ],
                       [ 1,1,0.52127 ], [ 0.54787,0.93351,0.56914 ], [ 0.80585,0.81648,0.82180 ] ]);
           break;
        case "Dark":
           palette = new Palette("RGB",['0','0.18241042','0.38599348','0.57166123','0.78338762','1'],
                         [  [0.65957446,0,0],[0,0.30585106,0.58776595],[0.81648936,0.41489361,0.07180851],
                                [0,0.48670212,0.16489361],[0.29787234,0.13829787,0.75],[0.65957446,0,0] ]);
//           palette = new Palette("RGB",[0,0.18241,0.38599,0.57166,0.78338,1],
//                       [ [0.65957,0,0],[0,0.40159,0.74734],[0.87234,0.49202,0.07180],
//                           [0,0.48670,0.16489],[0.29787,0.13829,0.75], [0.65957,0,0] ]);
           break;
        case "Random":
           var c = [Math.random(),Math.random(),Math.random()];
           palette = new Palette("RGB",[],[]);
           palette.divisionPoints[0] = 0;
           palette.divisionColors[0] = c;
           for (var i = 1; i <= 5; i++) {
               palette.divisionPoints[i] = i/6;
               palette.divisionColors[i] = [Math.random(),Math.random(),Math.random()];
           }
           palette.divisionPoints[6] = 1;
           palette.divisionColors[6] = c;
           break;
        case "Custom":
            palette = paletteSelectSlider.data.customPalette;
            break;
        case "Spectrum":
            palette = new Palette();
            break;
        default:
            console.error("unknown palette:", name);
            break;
    }
    return palette;
};

//----- Palette Editor ---------------------------------------------------------------

function showPaletteEditor() {
    if (!colorEditCanvas) {  // showing for the first time, do initialization
        document.getElementById("applyPaletteEdit").onclick = applyAndClose;
        document.getElementById("revertPaletteEdit").onclick = revert;
        document.getElementById("dismissPaletteEdit").onclick = dismiss;
        document.getElementById("addcolorstop").onclick = function() { colorEditCanvas.addColorStop(); };
        document.getElementById("deletecolorstop").onclick = function() { colorEditCanvas.deleteColorStop(); };
        document.getElementById("lockcolors").onchange = setLeftRightColorsLocked;
        document.getElementById("paletteEditStandardInstall").onclick = installStandard;
        document.getElementById("paletteEditStandardSelect").value = "EarthAndSky";
        document.addEventListener("keydown", doKey, false);
        updateDuringDrag = document.getElementById("updateWhileDraggingCheck").checked;
        document.getElementById("updateWhileDraggingCheck").oninput = function() { 
           updateDuringDrag =document.getElementById("updateWhileDraggingCheck").checked;
        };
        histogramPalette = document.getElementById("histogrampalette");
        colorEditCanvas = new ColorEditCanvas();
        colorSliders = [ 
           new SliderAndInput(document.getElementById("colorslider0"), document.getElementById("colorinput0"), 0, 1),
           new SliderAndInput(document.getElementById("colorslider1"), document.getElementById("colorinput1"), 0, 1),
           new SliderAndInput(document.getElementById("colorslider2"), document.getElementById("colorinput2"), 0, 1)
        ];
        colorSliders[0].onchange = function(v) { newColorSliderValue(0,v); };
        colorSliders[1].onchange = function(v) { newColorSliderValue(1,v); };
        colorSliders[2].onchange = function(v) { newColorSliderValue(2,v); };
        paletteLengthSlider = new SliderAndInput(document.getElementById("lengthslider"), document.getElementById("editorlengthinput"), 1, maxIterSlider.value, paletteLength, true, true);
        paletteOffsetSlider = new SliderAndInput(document.getElementById("offsetslider"), document.getElementById("editoroffsetinput"), 0, 100, mainPaletteOffsetSlider.value);
        paletteLengthSlider.onchange = newPaletteMappingInEditor;
        paletteOffsetSlider.onchange = newPaletteMappingInEditor;
    }
    paletteEditInProgress = true;
    document.getElementById("paletteEditor").style.display="block";
    document.getElementById("xmlimportbg").style.display = "block";
    copyOfCurrentPalette = palette.copy();
    histogram = new Histogram();
    palettePreview = new PalettePreview();
    installPaletteInEditor(palette);
    paletteLengthSlider.reset(1,maxIterSlider.value,paletteLength);
    paletteOffsetSlider.setValue(mainPaletteOffsetSlider.value);
    document.getElementById("applyPaletteEdit").disabled = true;
    document.getElementById("revertPaletteEdit").disabled = true;
    function applyAndClose() {
        let oldPaletteSelectSliderState = paletteSelectSlider.getPaletteSelectSliderState();
        paletteSelectSlider.setCustomPalette(paletteInEditor);
        var newval = [paletteInEditor, paletteLengthInEditor, paletteOffsetFractionInEditor,
            paletteSelectSlider.getPaletteSelectSliderState()];
        addUndoItem("Edit Palette", 
                [copyOfCurrentPalette, fixedPaletteLength, mainPaletteOffsetSlider.value/100,
                    oldPaletteSelectSliderState], 
                newval);
        applyUndoItem("Edit Palette", newval);
        dismiss();
    }
    function dismiss() {
        document.getElementById("xmlimportbg").style.display = "none";
        document.getElementById("paletteEditor").style.display = "none";
        document.removeEventListener("keydown", doKey, false);
        paletteEditInProgress = false;
        histogram = null;
        palettePreview = null;
        paletteInEditor = null;
        colorsInEditor = null;
    }
    function revert() { 
        installPaletteInEditor( copyOfCurrentPalette );
        palettePreview.redraw();
        document.getElementById("applyPaletteEdit").disabled = true;
        document.getElementById("revertPaletteEdit").disabled = true;
    }
    function installStandard() {
        var name = document.getElementById("paletteEditStandardSelect").value;
        var p = Palette.createStandardPalette(name);
        installPaletteInEditor( p, paletteLengthInEditor, paletteOffsetFractionInEditor );
        document.getElementById("applyPaletteEdit").disabled = false;
        document.getElementById("revertPaletteEdit").disabled = false;
        palettePreview.redraw();
    }
    function doKey(evt) {
        var code = evt.keyCode;
        if (code == 27) {
            dismiss();
        }
    }
}

var copyOfCurrentPalette;
var paletteInEditor;
var paletteLengthInEditor;
var paletteOffsetFractionInEditor;
var histogram;
var histogramPalette;
var palettePreview;
var colorEditCanvas = null;
var leftRightColorsLocked;
var saveRightColorWhileLocked;
var colorsInEditor;
var colorSliders;
var paletteLengthSlider;
var paletteOffsetSlider;
var updateDuringDrag;

function installPaletteInEditor(palette,length,offsetFraction) {
    paletteInEditor = palette.copy();
    var leftCol = paletteInEditor.divisionColors[0];
    var rightCol = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
    var locked = leftCol[1] == rightCol[1] && leftCol[2] == rightCol[2] &&
           (leftCol[0] == rightCol[0] || (paletteInEditor.colorType == "HSB" &&
                leftCol[0] - Math.floor(leftCol[0]) == rightCol[0] - Math.floor(rightCol[0])));
    colorEditCanvas.setLocked(locked,true);
    document.getElementById("lockcolors").checked = locked;
    paletteLengthInEditor = (typeof length != "undefined")? length : paletteLength;
    paletteLengthSlider.setValue(paletteLengthInEditor);
    paletteOffsetFractionInEditor = (typeof offsetFraction != "undefined")? offsetFraction : mainPaletteOffsetSlider.value/100;
    paletteOffsetSlider.setValue(paletteOffsetFractionInEditor*100);
    colorEditCanvas.colorsChanged();
    colorEditCanvas.select(0);
    newColorsInEditor();
    if (!updateDuringDrag)
        palettePreview.redraw();
    if (palette.colorType == "RGB") {
        document.getElementById("colorlabel0").innerHTML = "Red";
        document.getElementById("colorlabel1").innerHTML = "Green";
        document.getElementById("colorlabel2").innerHTML = "Blue";
    }
    else {
        document.getElementById("colorlabel0").innerHTML = "Hue";
        document.getElementById("colorlabel1").innerHTML = "Saturation";
        document.getElementById("colorlabel2").innerHTML = "Brightness";
    }
    if (palette.colorType == "HSB")
        colorSliders[0].setAllowOutOfRange( true, true  );
    else
        colorSliders[0].setAllowOutOfRange( false, false);
    if (palette.colorType == "HSB") { 
       var n = Math.floor(palette.divisionColors[0][0]);
       colorSliders[0].reset(n,n+1,palette.divisionColors[0][0]);
       colorSliders[0].canvas.title = "Drag the slider to set the hue of the selected color stop to a value in the range " +
                                       n + " to " + (n+1) + ". Values outside this range can be set in the textbox.";
    }
    else {
       colorSliders[0].reset(0,1,palette.divisionColors[0][0]);
       colorSliders[0].canvas.title = "Drag the slider to set the red component of the selected color stop to a value in the range 0.0 to 1.0.";
    }
    colorSliders[1].setValue(palette.divisionColors[0][1]);
    colorSliders[2].setValue(palette.divisionColors[0][2]);
}

function newColorsInEditor() {
    var offset = Math.round(paletteLengthInEditor * paletteOffsetFractionInEditor);
    colorsInEditor = paletteInEditor.makeCanvasColors(paletteLengthInEditor,offset);
    colorEditCanvas.draw();
    if (updateDuringDrag)
        palettePreview.redraw();
    redrawHistogramPalette();
    document.getElementById("applyPaletteEdit").disabled = false;
    document.getElementById("revertPaletteEdit").disabled = false;
}

function newPaletteMappingInEditor() {
    paletteLengthInEditor = paletteLengthSlider.value;
    paletteOffsetFractionInEditor = paletteOffsetSlider.value / 100;
    var offset = Math.round(paletteLengthInEditor * paletteOffsetFractionInEditor);
    colorsInEditor = paletteInEditor.makeCanvasColors(paletteLengthInEditor,offset);
    if (updateDuringDrag)
        palettePreview.redraw();
    redrawHistogramPalette();
    document.getElementById("applyPaletteEdit").disabled = false;
    document.getElementById("revertPaletteEdit").disabled = false;
}

function newColorSliderValue(componentIndex,value) {
   var colorNum = colorEditCanvas.getSelected();
   var color = paletteInEditor.divisionColors[colorNum];
   color[componentIndex] = value;
   var color2 = null;
   if (leftRightColorsLocked) {
       if (colorNum == 0) {
           color2 = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
       }
       else if (colorNum == paletteInEditor.divisionColors.length-1) {
           color2 = paletteInEditor.divisionColors[0];
       }
   }
   if (color2 != null) {
       if (componentIndex == 0 && paletteInEditor.colorType == "HSB") {
           var n = Math.floor(color2[0]);
           color2[0] = n + (value - Math.floor(value));
       }
       else {
           color2[componentIndex] = value;
       }
       saveRightColorWhileLocked = null;
   }
   colorEditCanvas.colorsChanged();
   newColorsInEditor();
}

function redrawHistogramPalette() {
     var hg = histogramPalette.getContext('2d');
     var onecopy = paletteLengthInEditor/maxIterSlider.value * (histogramPalette.width-2);
     for (var i = 1; i < histogramPalette.width-1; i++) {
         var fraction = ((i-1) % onecopy) / onecopy;
         var index = Math.max(0, Math.min(colorsInEditor.length,Math.round(fraction * colorsInEditor.length)));
         hg.fillStyle = colorsInEditor[index];
         hg.fillRect(i,0,1,histogramPalette.height);
     }
     hg.strokeStyle = "black";
     hg.strokeRect(0.5,0.5,histogramPalette.width-1,histogramPalette.height-1);
}

function setLeftRightColorsLocked() {
    var locked = document.getElementById("lockcolors").checked;
    colorEditCanvas.setLocked(locked);
}

function ColorEditCanvas() {
    var canvas = document.getElementById("coloredit");
    var g = canvas.getContext('2d');
    var size = canvas.width - 16;
    var colors = null;
    var selected;
    var prevX;
    var me = this;
    new Mouser(canvas, 
       function(x,y) {
           for (var i = 0; i < paletteInEditor.divisionPoints.length; i++) {
              var p = 8 + Math.floor(paletteInEditor.divisionPoints[i] * size);
              if ((x > p-2 && x < p+3) || (y > 48 && (x > p-6 & x < p+7))) {
                  prevX = x;
                  if (i != selected) {
                      me.select(i);
                      me.draw();
                  }
                  return i > 0 && i < paletteInEditor.divisionPoints.length - 1;
              }
           }
           return false;
       },
       function (x,y) {
            var position = 8 + Math.floor(paletteInEditor.divisionPoints[selected] * size);
            var left = 8 + Math.floor(paletteInEditor.divisionPoints[selected-1] * size);
            var right = 8 + Math.floor(paletteInEditor.divisionPoints[selected+1] * size);
            var change = x - prevX;
            prevX = x;
            var newposition = Math.min(right-10,Math.max(left+10,position + change));
            if (newposition != position) {
                paletteInEditor.divisionPoints[selected] = (newposition-8)/size;
                colors = null;
                newColorsInEditor();
            }
       },
       function () {
               if (!updateDuringDrag)
                   palettePreview.redraw();
           }
     );
     canvas.ondblclick = function(evt) {
        if (evt.button != 0)
           return;
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;    
        if (y > 50)
           return;
        for (var i = 1; i < paletteInEditor.divisionPoints.length; i++) {
            var leftDP = paletteInEditor.divisionPoints[i-1];
            var rightDP = paletteInEditor.divisionPoints[i];
            var left = 8 + Math.floor( leftDP * size);
            var right = 8 + Math.floor(rightDP * size);
            if (x > left+9 && x < right-9) {
                var divisionPt = (x-8)/size;
                var t = (divisionPt - leftDP) / (rightDP - leftDP);
                var leftCol = paletteInEditor.divisionColors[i-1];
                var rightCol = paletteInEditor.divisionColors[i];
                var col = [ (1-t)*leftCol[0]+t*rightCol[0], (1-t)*leftCol[1]+t*rightCol[1], (1-t)*leftCol[2]+t*rightCol[2] ];
                paletteInEditor.divisionPoints.splice(i,0,divisionPt);
                paletteInEditor.divisionColors.splice(i,0,col);
                me.select(i);
                me.draw();
                break;
            }
        }
     };
     this.addColorStop = function() {
         var left = selected - 1;
         var right = selected + 1; 
         while (left >= 0 || right < paletteInEditor.divisionPoints.length) {
                // try to find room alternately to left and to right of selected stop
            if (placeColorStopBetween(right-1,right))
               return;
            right++;
            if (placeColorStopBetween(left,left+1))
                return;
            left--;
         }
         alert("Sorry, can't find room for another color stop.");
         function placeColorStopBetween( a, b ) {  // b - a = 1
             if (a < 0 || b >= paletteInEditor.divisionPoints.length)
                return false;
             var leftDP = paletteInEditor.divisionPoints[a];
             var rightDP = paletteInEditor.divisionPoints[b];
             if ( (rightDP-leftDP)*size > 19) {
                var divisionPt = (leftDP + rightDP)/2;
                var leftCol = paletteInEditor.divisionColors[a];
                var rightCol = paletteInEditor.divisionColors[b];
                var col = [ (leftCol[0]+rightCol[0])/2, (leftCol[1]+rightCol[1])/2, (leftCol[2]+rightCol[2])/2 ];
                paletteInEditor.divisionPoints.splice(b,0,divisionPt);
                paletteInEditor.divisionColors.splice(b,0,col);
                me.select(b);
                me.draw();
                return true;
             }
             return false;
         }
     };
     this.deleteColorStop = function() {
         if (selected > 0 && selected < paletteInEditor.divisionPoints.length-1) {
             paletteInEditor.divisionPoints.splice(selected,1);
             paletteInEditor.divisionColors.splice(selected,1);
             me.select(selected-1);
             colors = null;
             newColorsInEditor();
             me.draw();
         }
     };
     this.setLocked = function(lock,onInstall) {
         leftRightColorsLocked = lock;
         if (onInstall) {
             saveRightColorWhileLocked = null;
             return;
         }
         var leftCol = paletteInEditor.divisionColors[0];
         var rightCol = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
         if (leftRightColorsLocked) {
            var save = [];
            save.push(rightCol[0]);
            save.push(rightCol[1]);
            save.push(rightCol[2]);
            rightCol[1] = leftCol[1];
            rightCol[2] = leftCol[2];
            if (paletteInEditor.colorType == "HSB") {
                var n = Math.floor(rightCol[0]);
                rightCol[0] = n + (leftCol[0] - Math.floor(leftCol[0]));
            }
            else {
                rightCol[0] = leftCol[0];
            }
            colors = null;
            newColorsInEditor();
            if (selected == paletteInEditor.divisionColors.length-1)
               me.select(selected);
            saveRightColorWhileLocked = save;
         }
         else if (saveRightColorWhileLocked != null) {
            rightCol[0] = saveRightColorWhileLocked[0];
            rightCol[1] = saveRightColorWhileLocked[1];
            rightCol[2] = saveRightColorWhileLocked[2];
            saveRightColorWhileLocked = null;
            colors = null;
            newColorsInEditor();
            if (selected == paletteInEditor.divisionColors.length-1)
               me.select(selected);
         }
     };
     this.select = function(colorIndex) {
         selected = colorIndex;
         if (paletteInEditor.colorType == "HSB") { 
            var n = Math.floor(paletteInEditor.divisionColors[selected][0]); 
            colorSliders[0].reset(n,n+1,paletteInEditor.divisionColors[selected][0]);
            colorSliders[0].canvas.title = "Drag the slider to set the hue of the selected color stop to a value in the range " +
                                            n + " to " + (n+1) + ". Values outside this range can be set in the textbox.";
         }
         else {
             colorSliders[0].setValue(paletteInEditor.divisionColors[selected][0]);
         }
         colorSliders[1].setValue(paletteInEditor.divisionColors[selected][1]);
         colorSliders[2].setValue(paletteInEditor.divisionColors[selected][2]);
         document.getElementById("deletecolorstop").disabled = !(selected > 0 && selected < paletteInEditor.divisionPoints.length-1);
     };
     this.getSelected = function() {
        return selected;
     };
     this.colorsChanged = function() {
        colors = null;
     };
     this.draw = function() {
         g.fillStyle = "#e8e8e8";
         g.fillRect(0,0,canvas.width,canvas.height);
         if (colors == null)
             colors = paletteInEditor.makeCanvasColors(size,0);
         for (var i = 0; i < size; i++) {
             g.fillStyle = colors[i];
             g.fillRect(8+i,3,1,40);
         }
         g.lineWidth = 2;
         g.strokeRect(7,2,size+2,41);
         for (var i = 0; i < paletteInEditor.divisionPoints.length; i++) {
            var x = 8 + Math.floor(paletteInEditor.divisionPoints[i] * size);
            var c = paletteInEditor.divisionColors[i]; 
            c = paletteInEditor.toRGB(c[0],c[1],c[2]); 
            c = "rgb(" + c[0] + "," + c[1] + "," + c[2] + ")";
            if ( i == selected ) {
                g.fillStyle = "black";
                g.fillRect(x-3,1,6,42);
                g.fillRect(x-7,51,14,29);
                g.fillStyle = "lightgray";
                g.fillRect(x-2,2,4,40);
                g.fillRect(x-6,52,12,27);
                g.fillStyle = c;
                g.fillRect(x-1,3,2,38);
            }
            g.fillStyle = "black";
            g.fillRect(x-1,43,2,10);
            g.fillRect(x-5,53,10,25);
            g.fillStyle = c;
            g.fillRect(x-4,54,8,23);
         }
     };
}

function PalettePreview() {
   var previewIterationCounts;
   var previewRect;
   var preview = document.getElementById("preview");
   var g = preview.getContext("2d");
   if (canvas.width >= canvas.height) {
       var h = Math.round(canvas.height/canvas.width * (preview.height-2));
       previewRect = { left:1, top: 1+Math.floor((preview.height-h)/2), width: preview.width-2, height: h };
   }
   else {
       var w = Math.round(canvas.width/canvas.height * (preview.width-2));
       previewRect = { left: 1+Math.floor((preview.width-w)/2), top: 1, width: w, height: preview.height-2 };
   }
   var previewCounts = new Array(previewRect.height);
   var desiredRow = new Array(previewRect.height+1);
   var currentRow = new Array(previewRect.height);
   var i,j;
   for (i = 0; i < previewRect.height; i++) {
       desiredRow[i] = Math.floor( i * canvas.height/previewRect.height );
       currentRow[i] = -1;
   }
   desiredRow[previewRect.height+1] = canvas.height;
   for (i = 0; i < previewRect.height; i++) {
       for (j = desiredRow[i]; j < desiredRow[i+1]; j++) {
           if (savedIterationCounts[j]) {
               currentRow[i] = j;
               previewCounts[i] = new Int32Array(previewRect.width);
               for (var k = 0; k < previewRect.width; k++) {
                   var index = Math.floor( k / previewRect.width * savedIterationCounts[j].length );
                   previewCounts[i][k] = savedIterationCounts[j][index];
               }
               break;
           }
       }
   }
   this.update = function(newRowNumber, newRowCounts) {
      for (var k = 0; k < previewRect.height; k++) { 
          if (newRowNumber < desiredRow[k+1]) { 
             if (currentRow[k] == -1 || (currentRow[k] != desiredRow[k] && newRowNumber < currentRow[k])) { 
                 currentRow[k] = newRowNumber;
                 newColors(k,newRowCounts);
             }
             break;
          }
      }
   };
   function newColors(row,counts) {
       previewCounts[row] = new Int32Array(previewRect.width);
       for (var k = 0; k < previewRect.width; k++) {
           var index = Math.floor( k / previewRect.width * counts.length );
           previewCounts[row][k] = counts[index];
       }
       showRow(row);
   }
   function showRow(row) { 
       for (var k = 0; k < previewRect.width; k++) {
           if (previewCounts[row][k] == -1)
               g.fillStyle="black";
           else {
               var index = previewCounts[row][k] % paletteLengthInEditor;
               g.fillStyle = colorsInEditor[index];
           }
           g.fillRect(k+previewRect.left,row+previewRect.top,1,1);
       }
   }
   function drawBG() {
      g.fillStyle="#e8e8e8";
      g.fillRect(0,0,preview.width,preview.height);
      g.lineWidth = 1;
      g.strokeStyle = "black";
      g.strokeRect( previewRect.left-0.5, previewRect.top-0.5, previewRect.width+1, previewRect.height );
   }
   this.redraw = function() {
      drawBG();
      for (var i = 0; i < previewCounts.length; i++) {
         if (previewCounts[i])
             showRow(i);
      }
   };
}

function Histogram() {
   var canvas = document.getElementById("histogram");
   var histogramWidth = canvas.width - 15;
   var histogramHeight = canvas.height - 15;
   var histogramCounts = new Int32Array(maxIterSlider.value+1);
   for (var j = 0; j < savedIterationCounts.length; j++) {
       if (savedIterationCounts[j]) {
          var counts = savedIterationCounts[j];
          for (var k = 0; k < counts.length; k++)
              histogramCounts[counts[k]] ++;
       }
   }
   this.update = function(newcounts) {
       for (var i = 0; i < newcounts.length; i++) {
           histogramCounts[newcounts[i]] ++;
       }
       redraw();
   };
   function redraw() {
       var g = canvas.getContext("2d");
       g.fillStyle = "white";
       g.fillRect(0,0,canvas.width,canvas.height);
       g.lineWidth = 2;
       g.strokeStyle = "red";
       g.beginPath();
       g.moveTo(8,5);
       g.lineTo(8,canvas.height-8);
       g.lineTo(canvas.width-5,canvas.height-8);
       g.stroke();
       var i,a,b;
       var maxct = 0;
       for (i = 1; i < histogramCounts.length; i++)
           maxct = Math.max(histogramCounts[i],maxct);
       if (maxct == 0)
           return;
       g.lineWidth=1;
       g.strokeStyle="black";
       g.beginPath();
       for (i = 1; i < histogramCounts.length; i++) {
           if (histogramCounts[i] > 0) {
               a = Math.round(i/histogramCounts.length * histogramWidth) + 10.5;
               b = Math.ceil(histogramCounts[i]/maxct * histogramHeight) + 0.5; 
               g.moveTo(a,canvas.height-10);
               g.lineTo(a,canvas.height-10-b);
           }
       }
       g.stroke();
   }
   redraw();
}

function SliderAndInput(canvas,textbox,min,max,val,integerOnly,allowOutOfRange) {
    this.canvas = canvas;
    this.textbox = textbox;
    this.min = (typeof min == "number")? min : 0.0;    
    this.max = (typeof max == "number")? max : this.min + 100.0;    
    this.value = (typeof val == "number")? val : this.min;
    this.integerOnly = (typeof integerOnly == "undefined")? false : integerOnly;
    this.allowOutOfRange = (typeof allowOutOfRange == "undefined")? false : allowOutOfRange;
    this.allowLessThanMin = false;
    this.g = this.canvas.getContext("2d");
    this.g.translate(0,-8);  // fudge for resuing old code
    this.size = this.canvas.width - 25;
    if (this.allowOutOfRange)
       this.size -= 20;
    this.setTabLeft();
    this.valueToTextbox();
    this.draw();
    this.onchange = null;
    var me = this;
    var valueInTextbox, savedValueWhileEditing, saveTitle;
    textbox.style.color = "black";
    textbox.style.backgroundColor = "white";
    textbox.style.padding = "2px";
    textbox.onfocus = function() { 
        valueInTextbox = savedValueWhileEditing = this.value; 
        textbox.style.backgroundColor="#d8ffd8";
        saveTitle = textbox.title;
        textbox.title = "Editing slider value. Press return or move to another input box to apply the new value, if legal.";
    };
    textbox.onblur = function() { 
        textbox.style.backgroundColor="white";
        if (checkTextbox())
            me.setValue(valueInTextbox);
        else
            me.setValue(savedValueWhileEditing);
        if (!updateDuringDrag)
            palettePreview.redraw();
        me.valueToTextbox();
        textbox.title = saveTitle;
        textbox.style.backgroundColor = "white";
    };
    textbox.oninput = function() { 
        checkTextbox();
    };
    textbox.onkeydown = function(evt) {
       if (evt.keyCode == 13 && checkTextbox()) {
          me.setValue(valueInTextbox);
          valueInTextbox = me.value;
          if (!updateDuringDrag)
              palettePreview.redraw();
       }
    };
    function checkTextbox() {
       var val = Number(textbox.value);
       if (isNaN(val)) {
           textbox.style.backgroundColor = "#ff9090";
           textbox.title = "The value in the input box is not a number!";
           return false;
       }
       if (me.integerOnly)
          val = Math.round(val);
       if (val < 0 || (val < me.min && !me.allowLessThanMin) || (val > me.max && !me.allowOutOfRange)) {
           textbox.style.backgroundColor = "#ffff90";
           textbox.title = "The value in the textbox is not in the legal range for the slider";
           return false;
       }
       valueInTextbox = val;
       textbox.style.backgroundColor="#d8ffd8";
       textbox.title = "Editing slider value. Press return or move to another input box to apply the new value, if legal.";
       return true;
    }
    var offset;
    new Mouser(this.canvas,
        function(x,y) {
           if (y < 23 && x > me.tabLeft - 2 && x < me.tabLeft + 22) {
              offset = x - (me.tabLeft+10);
              return true;
           }
           else if (y > 20 && x > 14 && x < me.canvas.width - 5) {
              var val = (x - 15)/me.size * (me.max-me.min) + me.min;
              me.setValue(val);
              return false;
           }
        },
        function(x,y) {
           x = x - offset;
           var val = (x - 15)/me.size * (me.max-me.min) + me.min;
           if (val > me.max)
              val = me.max;
           if (val < me.min)
              val = me.min;
           me.setValue(val); 
        },
        function() {
            if (!updateDuringDrag)
                palettePreview.redraw();
        }
    );
}
SliderAndInput.prototype.setAllowOutOfRange = function( allow, allowLessThanMin ) {
    if (this.allowOutOfRange == allow && this.allowLessThanMin == allowLessThanMin)
       return;
    this.allowOutOfRange = allow;
    if (allowLessThanMin)
        this.allowLessThanMin = true;
    else
        this.allowLessThanMin = false;
    this.size = this.canvas.width - 25;
    if (this.allowOutOfRange)
       this.size -= 20;
    this.setTabLeft();
    this.draw();
};
SliderAndInput.prototype.reset = function(min,max,val) {
//    if (this.min != min || this.max != max) {
        this.min = min;
        this.max = max;
        this.value = "none";
        this.setValue(val);
//    }
};
SliderAndInput.prototype.setValue = function(val) { 
    var newval = this.integerOnly? Math.round(val) : val;
    if ( ! this.allowOutOfRange ) {
        newval = Math.min(this.max,newval);
    }
    if ( ! this.allowOutOfRange ) {
        newval = Math.max(this.min,newval);
    }
    newval = Math.max(0,newval);
    if (this.value != newval) { 
        this.value = newval;
        this.valueToTextbox();
        this.changed();
    }
};
SliderAndInput.prototype.valueToTextbox = function() {
    if (this.integerOnly)
        this.textbox.value = "" + this.value;
    else
        this.textbox.value = this.value.toPrecision(3);
};
SliderAndInput.prototype.setTabLeft = function() {
   if (this.value > this.max  || this.value < this.min)
      this.tabLeft = this.size + 20;
   else
      this.tabLeft = 5 + Math.floor((this.value - this.min)/(this.max - this.min) * this.size);
};
SliderAndInput.prototype.changed = function() {
   this.setTabLeft();
   this.draw();
   if (this.onchange)
      this.onchange(this.value);
};
SliderAndInput.prototype.draw = function() {
    var graphics = this.g;
    graphics.save();
    graphics.fillStyle = "#e8e8e8";
    graphics.fillRect(0,8,this.canvas.width,this.canvas.height);
    graphics.beginPath();
    graphics.moveTo(15, 35);
    graphics.lineTo(15 + this.size, 35);
    graphics.strokeStyle = "black";
    graphics.lineWidth = 10;
    graphics.lineCap = "round";
    graphics.stroke();
    graphics.strokeStyle = "gray";
    graphics.lineWidth = 7.5;
    graphics.lineCap = "butt";
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(15, 35);
    graphics.lineTo(Math.min(this.tabLeft + 10,15+this.size), 35);
    graphics.strokeStyle = "lightgray";
    graphics.stroke();
    graphics.fillStyle = "black";
    graphics.lineWidth = 1;
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 10, 36);
    graphics.lineTo(this.tabLeft + 20, 30);
    graphics.lineTo(this.tabLeft + 20, 10);
    graphics.lineTo(this.tabLeft, 10);
    graphics.lineTo(this.tabLeft, 30);
    graphics.closePath();
    graphics.fillStyle = "#9090FF";
    graphics.fill();
    graphics.strokeStyle = "#000099";
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 4.5, 14);
    graphics.lineTo(this.tabLeft + 4.5, 26);
    graphics.moveTo(this.tabLeft + 9.5, 14);
    graphics.lineTo(this.tabLeft + 9.5, 26);
    graphics.moveTo(this.tabLeft + 14.5, 14);
    graphics.lineTo(this.tabLeft + 14.5, 26);
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 6, 16);
    graphics.lineTo(this.tabLeft + 6, 28);
    graphics.moveTo(this.tabLeft + 11, 16);
    graphics.lineTo(this.tabLeft + 11, 28);
    graphics.moveTo(this.tabLeft + 16, 16);
    graphics.lineTo(this.tabLeft + 16, 28);
    graphics.strokeStyle = "white";
    graphics.stroke();
    graphics.restore();
};



//-------------------------------------------------------------------------------------------

function currentExampletoXML() {
    var offset = Math.round(mainPaletteOffsetSlider.value/100 * paletteLength);
    return "<?xml version='1.0'?>\n<mandelbrot_settings_2>\n" +
            "<image_size width='" + (fitWindow ? 0 : canvas.width) + "' height='" + (fitWindow ? 0 : canvas.height) + "'/>\n" +
            "<limits>\n   <xmin>" + xmin_requested.toString() + "</xmin>\n" +
            "   <xmax>" + xmax_requested.toString() + "</xmax>\n" +
            "   <ymin>" + ymin_requested.toString() + "</ymin>\n" +
            "   <ymax>" + ymax_requested.toString() + "</ymax>\n</limits>\n" +
            palette.toXMLString() +
            "<palette_mapping length='" + paletteLength + "' offset='" + offset + "'/>\n" +
            "<max_iterations value='" + maxIterSlider.value + "'/>\n" +
            "</mandelbrot_settings_2>\n";
}

function installExampleFromXML(xmlString, recordUndo, respectSize, dontShowError) {
    // console.log("installExampleFromXML:", currentXML, xmlString);
    let oldXML = currentXML;
    let oldPaletteSelectSliderState = paletteSelectSlider.getPaletteSelectSliderState();
    stopJob();
    try {
      var parser = new DOMParser();
      var doc = parser.parseFromString(xmlString,"text/xml").documentElement;
      var width,height,xmin,xmax,ymin,ymax,colors,length,offset,iterations;
      if (respectSize) {
          var size = doc.getElementsByTagName("image_size");
          if (size == 0) {
              respectSize = false;
          }
          else {
              width = Number(size[0].getAttribute("width"));
              height = Number(size[0].getAttribute("height"));
              if (width === 0 && height === 0) {
                    fitWindow = true;
              } else if (isNaN(width) || width > 7680 || width < 64 || isNaN(height) || height > 7680 || height < 64) {
                    respectSize = false;
              } else {
                    fitWindow = false;
              }
          }
      }
      xmin = doc.getElementsByTagName("xmin").item(0).textContent;
      xmax = doc.getElementsByTagName("xmax").item(0).textContent;
      ymin = doc.getElementsByTagName("ymin").item(0).textContent;
      ymax = doc.getElementsByTagName("ymax").item(0).textContent;
      colors = Palette.fromXML( doc.getElementsByTagName("palette").item(0));
      var map = doc.getElementsByTagName("palette_mapping");
      if (map.length > 0) {
          length = Number(map.item(0).getAttribute("length"));
          offset = Number(map.item(0).getAttribute("offset"));
      }
      else {
          length = 250;
          offset = 0;
      }
      iterations = Number(doc.getElementsByTagName("max_iterations").item(0).getAttribute("value"));
      xmin = new BigDecimal(xmin);
      xmax = new BigDecimal(xmax);
      ymin = new BigDecimal(ymin);
      ymax = new BigDecimal(ymax);
      if (isNaN(length) || isNaN(offset) || isNaN(iterations)) {
          throw "Bad number.";
      }
      iterations = maxIterSlider.setValue(Math.round(iterations));
      if (length == 0) {
          length = iterations;
      }
      palette = colors;
      paletteSelectSlider.setCustomPalette(palette);

      length = Math.round(length);
      mainPaletteLengthSlider.setMaxValue(Math.max(2*length, 2*iterations), false);
      mainPaletteLengthSlider.setValue(length);
      fixedPaletteLength = length;

      let tmp = offset/length;
      tmp = tmp - Math.floor(tmp);
      tmp = Math.round(10000*tmp)/10000;
      mainPaletteOffsetSlider.setValue(tmp*100);
      createPaletteColors();
      if (respectSize) {
        setImageSize(width, height, false);
         var val = width + " " + height;
         if (! fitWindow && ["640 480", "800 600", "1024 768", "1600 1200", "1920 1080", "1920 1200", "2560 1440", "2880 1800", "3840 1080", "3840 2160", "5120 1440", "7680 4320"].indexOf(val) < 0) {
             document.getElementById("imagesize").value = "Custom";
             document.getElementById("customsize").style.display = "inline";
             document.getElementById("customwidth").value = "" + width;
             document.getElementById("customheight").value = "" + height;
         }
         else {
             document.getElementById("imagesize").value = fitWindow ? "0 0" : val;
             document.getElementById("customsize").style.display = "none";
         }
      }
      setLimits(xmin,xmax,ymin,ymax,false);
      startJob();
      if (recordUndo && undoList) {
          addUndoItem("Import Example", [oldXML, oldPaletteSelectSliderState],
            [currentXML, paletteSelectSlider.getPaletteSelectSliderState()]);
      }
      return null;
    }
    catch (e) {
        var error =  "Illegal data in XML example string: " + e;
        if ( ! dontShowError )
           document.getElementById("status").innerHTML = error;
        return error;
    }
}

function installExampleWithAjax(url) {
    document.getElementById("status").innerHTML = "Trying to Fetch example from " + url;
    var ajaxTimeout;
    var ajax = new XMLHttpRequest();
    ajax.open("GET",url);
    ajax.overrideMimeType("text/plain");
    ajax.addEventListener("error",function() {
        clearTimeout(ajaxTimeout);
        document.getElementById("status").innerHTML = "Error: Example could not be loaded from " + url;
    });
    ajax.addEventListener("load",function() {
        clearTimeout(ajaxTimeout);
        installExampleFromXML(ajax.responseText, false, false);
    });
    ajaxTimeout = setTimeout(function() {
        ajax.abort();
        document.getElementById("status").innerHTML = "Error: Request timed out while trying to load from " + url;
    }, 10000);
    try {
       ajax.send();
    } catch(e) {
        clearTimeout(ajaxTimeout);
        document.getElementById("status").innerHTML = "Error while trying to send request for example: " + url;
    }
}

function importXML() {
    document.getElementById("XMLtextinput").value = "";
    document.getElementById("xmlimportbg").style.display = "block";
    document.getElementById("xmlimport").style.display = "block";
    document.addEventListener("keydown", doKey, false);
    document.getElementById("cancelXMLimport").onclick = dismiss;
    document.getElementById("applyXMLimport").onclick = apply;
    document.getElementById("grabcurrent").onclick = grabCurrent;
    function apply() {
        var text = document.getElementById("XMLtextinput").value.trim();
        if (text == "") {
            dismiss();
        }
        else {
            var errorMsg = installExampleFromXML(text,true,false);
            if (errorMsg == null)
               dismiss();
            else
               alert("Error in input: " + errorMsg);
        }
    }
    function dismiss() {
        document.getElementById("xmlimportbg").style.display = "none";
        document.getElementById("xmlimport").style.display = "none";
        document.removeEventListener("keydown", doKey, false);
    }
    function grabCurrent() {
        document.getElementById("XMLtextinput").value = currentXML;
    }
    function doKey(evt) {
        var code = evt.keyCode;
        if (code == 27) {
            dismiss();
        }
    }
}

function checkForExample() {
    var ex = window.location.search.match("^\\?ex=([a-zA-Z0-9/.%_+-]+)");
    if (ex) {
       stopJob();
       installExampleWithAjax(decodeURIComponent(ex[1]), false);
    }
}

function init() {
    try {
        canvas = document.getElementById("canvas");
        graphics = canvas.getContext("2d");
        OSC = document.createElement("canvas");
        OSC.width = canvas.width;
        OSC.height = canvas.height;
        OSG = OSC.getContext("2d", { willReadFrequently: true });
    }
    catch (e) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires canvas support, which is not available in your browser.";
         return;
    }
    if (! window.Worker ) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires WebWorker support, which is not available in your browser.";
         return;
    }
    palette = new Palette();
    document.getElementById("restoreButton").onclick = setDefaults;
    document.getElementById("stop").onclick = stopJob;
    document.getElementById("interlaced").onchange = changeInterlaced;
    document.getElementById("interlaced").checked = interlaced;
    document.getElementById("imagesize").onchange = changeImageSize;
    document.getElementById("applysize").onclick = doCustomSize;
    // must run before worker count init
    initLocalOrRemote();
    try {
        var ct = Number(localStorage.getItem("mandelbrotWorkerCount" + (document.getElementById("local").checked ? "local" : "remote")));
        // console.log("workers get (init) " + (document.getElementById("local").checked ? "local" : "remote") + " " + ct);
        if (!isNaN(ct) && ct > 0) {
            workerCount = ct;
        }
    }
    catch(e) {
    }
    document.getElementById("threadCountSelect").value = "" + workerCount;
    document.getElementById("threadCountSelect").onchange = changeWorkerCount;
    document.getElementById("showpaletteedit").onclick=showPaletteEditor;
    document.getElementById("secondpass").checked = true;
    document.getElementById("secondpass").onchange = changeSecondPass;
    document.getElementById("highPrecision").checked = false;
    document.getElementById("highPrecision").onchange = changeHighPrecision;
    document.getElementById("local").onchange = changeLocalOrRemote;
    document.getElementById("remote").onchange = changeLocalOrRemote;
    document.getElementById("importXML").onclick = importXML;
    document.getElementById("undo").onclick = doUndo;
    document.getElementById("undo").disabled = true;
    document.getElementById("redo").onclick = doRedo;
    document.getElementById("redo").disabled = true;
    setUpDragging();
    setUpArrowKeys();
    changeWorkerCount(); // has to be done before setDefaults
    createSliders();
    setTooltipSize();
    window.addEventListener('resize', resizeFitWindow);
    setDefaults();
    checkForExample();
    undoList = [];
    undoCount = 0;
    checkRemoteCanComputeMB();
}

function getLocalStorageItem(item, defaultVal) {
    try {
        let value = localStorage.getItem(item);
        // console.log(item, value);
        if (value == null) {
            return defaultVal;
        } else {
            return value;
        }
    }
    catch(e) {
        return defaultVal;
    }
}
function setLocalStorageItem(item, value) {
    try {
        // console.log(item, value);
        localStorage.setItem(item, value);
    }
    catch(e) {
    }
}

function createSliders() {
    maxIterSlider = new Slider(
        "maxIterSlider", {
        label: "Max Iterations:",
        title: "How many steps in the Mandelbrot iteration before giving up and coloring the pixel black.",
        logarithmic: true, initialValue: 1000, minValue: 1, maxValue:999999, textLength: 6,
        stickyVals: [3,5,10,25,50,75,100,250,500,750,1000,2500,5000,7500,10000,25000,50000,75000,100000]
        });
    maxIterSlider.onInput = function (interimMaxIters, lastInterimMaxIters) {
        // console.log("i:",this.id,interimMaxIters);
        // check for palette length tracking maxIters
        if (mainPaletteLengthSlider.atMax()) {
            setFixedPaletteLength(interimMaxIters);
        }
    };
    maxIterSlider.onChange = function (newMaxIters, oldState) {
        setMaxIterations();
        let initialMPLSState = mainPaletteLengthSlider.getState();
        // if palette length is tracking maxIters, update palette max and set palette value to maxIters
        if (mainPaletteLengthSlider.atMax()) {
            mainPaletteLengthSlider.setMaxValue(newMaxIters, true);
        // else just update palette max if newMaxIters > current palette length
        } else if (2*newMaxIters > mainPaletteLengthSlider.value) {
            mainPaletteLengthSlider.setMaxValue(2*newMaxIters, false);
        }
        addUndoItem("Change MaxIterations", [oldState.value, initialMPLSState],
                [newMaxIters, mainPaletteLengthSlider.getState()]);
    };

    mainPaletteLengthSlider = new Slider(
        "mainPaletteLengthSlider", {
        label: "Palette Length:",
        title: "Size of the color palette for pixels outside the Mandebrot set. Drag all the way to the right to pin it to max iterations.",
        logarithmic: true, initialValue: 250, minValue: 2, maxValue: 999999, textLength: 6,
        stickyVals: [2,3,4,5,6,7,8,9,10,12,15,20,25,35,50,75,100,175,250,375,500,750,1000,1750,2500,3750,5000,7500,10000],
        textFormat: function (value) { return this.atMax() ? "MaxIter" : value; },
        notifyOnlyOnDifference: false,///??? why did I do this
        data: { lastPaletteLength: NaN }
        });
    mainPaletteLengthSlider.onInput = function (interimPaletteLength, lastInterimPaletteLength) {
        // console.log("i mPLS", interimPaletteLength, lastInterimPaletteLength, maxIterSlider.value);
        if (isNaN(this.data.lastPaletteLength)) {
            this.data.lastPaletteLength = this.value;
        }
        let paletteLength = this.atMax() ? maxIterSlider.value : interimPaletteLength;
        if (paletteLength !== this.data.lastPaletteLength) {
            setFixedPaletteLength(paletteLength);
            this.data.lastPaletteLength = paletteLength;
        } 
    };
    mainPaletteLengthSlider.onChange = function (newPaletteLength, oldState) {
        // console.log("c mPLS", newPaletteLength, oldState.value, maxIterSlider.value);
        if (this.atMax()) {
            if (this.maxValue !== maxIterSlider.value) {
                this.setMaxValue(maxIterSlider.value, true);
            }
        } else if (2*maxIterSlider.value > this.value) {
            if (this.maxValue !== 2*maxIterSlider.value) {
                this.setMaxValue(2*maxIterSlider.value, false);
            }
        }
        if (newPaletteLength != oldState.value || this.maxValue != oldState.maxValue) {
            addUndoItem("Change PaletteLength", oldState, this.getState());
        }
        this.onBlur();
    };
    mainPaletteLengthSlider.onBlur = function() {
        this.data.lastPaletteLength = NaN;
    };
    mainPaletteLengthSlider.setDefaultsFromMaxIter = function () {
        this.setMaxValue(2*maxIterSlider.value, false);
        this.setValue(maxIterSlider.value/2);
    };

    mainPaletteOffsetSlider = new Slider(
        "mainPaletteOffsetSlider", {
        label: "Palette Offset:",
        title: "Offsets the colors within the palette to get a different mapping.",
        logarithmic: false, initialValue: 0, minValue: 0, maxValue: 100, textLength: 5,
        stickyVals: [0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100],
        textFormat: (value) => value + "%",
        onInput: doPaletteOffset,
        onChange: finishDoPaletteOffset
        });

    paletteSelectSlider = new Slider(
        "paletteSelectSlider", {
        label: "Palette:",
        title: "Select one of the standard palettes of colors.",
        logarithmic: false, initialValue: 0, minValue: 0, maxValue: 10, textLength: 14,
        textFormat: function (value) { return this.data.paletteNamesList[value]; },
        textEdit: false,
        data: {
            oldPaletteNum: NaN,
            oldPalette: null,
            customPalette: null,
            paletteSelectList: ["Spectrum","EarthAndSky","Cyclic Fire","Seashore","TreeColors",
                "Pastels","Dark","HotAndCold","Blue/Gold","CyclicGrayscale","Random","Custom"],
            paletteNamesList: ["Spectrum","EarthAndSky","Fire","Seashore","Forest",
               "Pastel Colors","Dark Colors","HotAndCold","Blue/Gold","Grayscale","Random","Custom"]
        }});
    paletteSelectSlider.onInput = function(interimPaletteNum, lastInterimPaletteNum) {
        // console.log("i:",this.id,interimPaletteNum,lastInterimPaletteNum,this.data.oldPaletteNum);
        if (isNaN(this.data.oldPaletteNum)) {
            this.data.oldPaletteNum = lastInterimPaletteNum;
            this.data.oldPalette = palette.copy();
        }
        if (interimPaletteNum === this.data.oldPaletteNum) {
            // show original palette even if it was random
            doApplyStandardPalette(null, this.data.oldPalette);
        } else {
            doApplyStandardPalette(interimPaletteNum);
        }
    };
    paletteSelectSlider.onChange = function(newPaletteNum, oldState) {
        // console.log("c:", this.id, newPaletteNum, oldState.value);
        addUndoItem("Change Palette", [this.data.oldPalette, oldState.value],
            [palette.copy(), newPaletteNum]);
        this.onBlur();
        };
    paletteSelectSlider.onBlur = function() {
        this.data.oldPalette = null;
        this.data.oldPaletteNum = NaN;
    };
    paletteSelectSlider.reset = function() {
        let max = this.data.paletteSelectList.length - 1;
        this.setDefault();
        this.setMaxValue(max - 1, false);
    };
    paletteSelectSlider.paletteName = function(paletteNum) {
        return this.data.paletteSelectList[paletteNum];
    };
    paletteSelectSlider.setCustomPalette = function(palette) {
        let max = this.data.paletteSelectList.length - 1;
        this.setMaxValue(max, true);
        this.data.customPalette = palette.copy();
    };
    paletteSelectSlider.getPaletteSelectSliderState = function() {
        // console.log("gPSSS:", this.data.customPalette);
        return [
            this.getState(),
            this.data.customPalette
        ];
    }
    paletteSelectSlider.setPaletteSelectSliderState = function(state) {
        this.setState(state[0]);
        this.data.customPalette = state[1];
        // console.log("sPSSS:", this.data.customPalette);
    }

    let initialValue = parseInt(getLocalStorageItem("zoomInSlider", 10));
    zoomInSlider = new Slider(
        "zoomInSlider", {
        label :"Zoom in by",
        title: "Sets the zoom in amount and then zooms.",
        logarithmic: true, initialValue: initialValue, minValue: 2, maxValue: 100000, textLength: 8,
        stickyVals: [2,4,8,10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,100000],
        textFormat: (value) => value + " X",
        button: true,
        onClick: () => doZoomIn(zoomInSlider.value),
        onChange: function (zoomValue) {
            doZoomIn(zoomValue);
            setLocalStorageItem(this.id, zoomValue);
        }});

    initialValue = parseInt(getLocalStorageItem("zoomOutSlider", 10));
    zoomOutSlider = new Slider(
        "zoomOutSlider", {
        label :"Zoom out by",
        title: "Sets the zoom out amount and then zooms.",
        logarithmic: true, initialValue: initialValue, minValue: 2, maxValue: 100000, textLength: 8,
        stickyVals: [2,4,8,10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,100000],
        textFormat: (value) => value + " X",
        button: true,
        onClick: () => doZoomOut(zoomOutSlider.value),
        onChange: function (zoomValue) {
            doZoomOut(zoomValue);
            setLocalStorageItem(this.id, zoomValue);
        }});
}

console.log(window.location.hostname, window.location.pathname);

let fullWindowCanvas = false;
let fullScreenCanvas = false;
let oldCanvasWidth = NaN;
let oldCanvasHeight = NaN;

function resizeFullWindowCanvas() {
    // console.log("resizeFullWindowCanvas:", window.innerWidth, window.innerHeight);
    setImageSizeToFixed(window.innerWidth, window.innerHeight, false);
}
function toFullWindowCanvas() {
    window.addEventListener('resize', resizeFullWindowCanvas);
    oldCanvasWidth = canvas.width;
    oldCanvasHeight = canvas.height;
    canvas.classList.add('FullWindowCanvas');
    setImageSizeToFixed(window.innerWidth, window.innerHeight, false);
    fullWindowCanvas = true;
}
function fromFullWindowCanvas() {
    window.removeEventListener('resize', resizeFullWindowCanvas);
    canvas.classList.remove('FullWindowCanvas');
    setImageSize(oldCanvasWidth, oldCanvasHeight, false);
    fullWindowCanvas = false;
}
function toFullScreenCanvas() {
    oldCanvasWidth = canvas.width;
    oldCanvasHeight = canvas.height;
    canvas.classList.add('FullWindowCanvas');
    canvas.requestFullscreen();
    document.addEventListener("fullscreenchange", escapeFromFullScreenCanvas);
    setImageSizeToFixed(screen.width, screen.height, false);
    fullScreenCanvas = true;
}
function fromFullScreenCanvas() {
    document.removeEventListener("fullscreenchange", escapeFromFullScreenCanvas);
    canvas.classList.remove('FullWindowCanvas');
    if (document.fullscreenElement) {
        document.exitFullscreen();
    }
    setImageSize(oldCanvasWidth, oldCanvasHeight, false);
    fullScreenCanvas = false;
}
function escapeFromFullScreenCanvas() {
    if (! document.fullscreenElement) {
            fromFullScreenCanvas();
    }
}

let arrowTimeout;
function setUpArrowKeys() {
    document.addEventListener("keydown", function(event) {
        // quit when in a text box
        if (event.target.nodeName === "INPUT" && (event.target.type === "text" || event.target.type === "range")) {
            return;
        }
        if (event.target.nodeName === "TEXTAREA" && event.target.type === "textarea") {
            return;
        }

        let doStartStop = false;
        switch (event.key) {
            case "ArrowLeft":
            case "ArrowRight":
            case "ArrowUp":
            case "ArrowDown":
            case "PageDown":
            case "PageUp":
                doStartStop = true;
                break;
            case "f":
            case "F":
            case "Escape":
                if (event.ctrlKey) {
                    return;
                }
                break;
            case "z":
            case "Z":
            case "y":
                if (event.ctrlKey) {
                    break;
                }
                return;
            default:
                // quit when this doesn't handle the key event
                return;
        }

        // Cancel the default action to avoid it being handled twice
        event.preventDefault();

        // prevent too many of these slowing down response
        if (arrowTimeout) {
            return;
        }

        if (doStartStop) {
            stopJob();
        }

        let doStart = true;
        const shiftLR = Math.max(1, Math.round(canvas.width/32));
        const shiftUD = Math.max(1, Math.round(canvas.height/32));
        switch (event.key) {
            case "ArrowLeft":
                doZoomInOnRect(-shiftLR, 0, canvas.width, canvas.height, false);
                break;

            case "ArrowRight":
                doZoomInOnRect(shiftLR, 0, canvas.width, canvas.height, false);
                break;

            case "ArrowUp":
                doZoomInOnRect(0, -shiftUD, canvas.width, canvas.height, false);
                break;

            case "ArrowDown":
                doZoomInOnRect(0, shiftUD, canvas.width, canvas.height, false);
                break;

            case "PageUp":
                doZoomInOnRect(-shiftLR, -shiftUD, canvas.width + shiftLR*2, canvas.height + shiftUD*2, false);
                break;

            case "PageDown":
                doZoomInOnRect(shiftLR, shiftUD, canvas.width - shiftLR*2, canvas.height - shiftUD*2, false);
                break;

            case "F":
                if (fullScreenCanvas) {
                    fromFullScreenCanvas();
                } else if (fullWindowCanvas) {
                    fromFullWindowCanvas();
                } else {
                    toFullScreenCanvas();
                }
                break;

            case "f":
                if (fullScreenCanvas) {
                    fromFullScreenCanvas();
                } else if (fullWindowCanvas) {
                    fromFullWindowCanvas();
                } else {
                    toFullWindowCanvas();
                }
                break;

            case "Escape":
                if (fullWindowCanvas) {
                    fromFullWindowCanvas();
                }
                break;

            case "z":
                doUndo();
                break;

            case "y":
            case "Z":
                doRedo();
                break;
        }

        arrowTimeout = setTimeout(function () {
            arrowTimeout = null;
            if (doStartStop) {
                startJob();
            }
        }, 0);
    });
}

</script>
</head>

<noscript><b>Sorry, this page requires JavaScript.</b></noscript>

<table id="header-table">
<tr><td>Explore the <a href=MB.html>Mandelbrot Set</a></span></td>
<td>
    <span class="tooltip">Help
        <span class="helptext">
            <h3>Basic Help</h3>
                Double-click the image to zoom in, or click and drag on it to zoom in to a rectangle.
                On the left is a selection of settings for the color palette, image size, etc.  Hover over a
                setting to see what it does.
            <h3>Special keys</h3>
                <table>
                    <tr><td>Left Arrow:</td><td>Scroll left</td></tr>
                    <tr><td>Right Arrow:</td><td>Scroll right</td></tr>
                    <tr><td>Up Arrow:</td><td>Scroll up</td></tr>
                    <tr><td>Down Arrow:</td><td>Scroll down</td></tr>
                    <tr><td>Page Up:</td><td>Zoom out on image</td></tr>
                    <tr><td>Page Down:</td><td>Zoom in on image</td></tr>
                    <tr><td>f:</td><td>Fill window with image</td></tr>
                    <tr><td>F (shift-f):</td><td>Fill screen with image</td></tr>
                    <tr><td>Esc</td><td>Exit fill window or fill screen mode</td></tr>
                    <tr><td>Ctrl-z</td><td>Undo last action</td></tr>
                    <tr><td>Ctrl-y</td><td>Redo last undone action</td></tr>
                </table>
                <br>
                For a detailed description, instructions, and examples, see <a href='MB-info.html'><b>more help</b></a>.
            <h3>More Info</h3>
                Increasing the number of "Workers" (in the left pane) brings in more CPU to speed up calculations. 
                To see, click on <a href="MB.html?ex=java%2FMandelbrotSettings%2FMandelbrotSettings_25_May_2009_3.xml">this link</a>, 
                then vary the number of workers to speed it up or slow it down.
            </p><p>
                Based on a browser-only Mandelbrot Set viewer by <a href=https://math.hws.edu/eck/index.html target="_blank">David Eck</a>,
                this revised version can run calculations in the browser or on a backend web server.  By default it tries to use the web server;
                if the web server doesn't support calculations it runs them in the browser.
                When the web server is hosted on Kubernetes, increasing the number of workers brings in more pods to speed up the computation.
                Calculations are done in Rust for increased speed over the original JavaScript version.
            </p><p>
                See the <a href="https://github.com/wpwoodjr/MandelRust" target="_blank">GitHub repository</a> for more information.
            </p>
        </span>
    </span>
</td>
<td>
    <span class="tooltip">Examples
        <span class="exampletext">
            <h3 id="gallery">Some Loadable Examples</h3>

            <p>Here are 15 images from the program.  Click on one of the images to open
            the program's web page and load that example.  The program will render a larger-size
            version of the image.  You can then use the program to do some further exploration.
            For example, click the "Zoom Out" button several times to see the neighborhood of
            the example in the full Mandelbrot set.  You will usually see several striking images
            along the way!  (There is also a large, unorganized
            <a href="java/MandelbrotSettings/index.html">collection&nbsp;of&nbsp;examples</a> that
            you can load into the program.)</p>
                
            <table id="examples">
            <tr>
               <td><a href="MB.html?ex=examples%2forangesky.xml"><img src="examples/orangesky.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fgalaxies.xml"><img src="examples/galaxies.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fspikey.xml"><img src="examples/spikey.png" width="200" height="150"></a></td>
            </tr>
            <tr>
               <td><a href="MB.html?ex=examples%2fvine.xml"><img src="examples/vine.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2ffire.xml"><img src="examples/fire.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fcrazy.xml"><img src="examples/crazy.png" width="200" height="150"></a></td>
            </tr>
            <tr>
               <td><a href="MB.html?ex=examples%2fdragon.xml"><img src="examples/dragon.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fflower.xml"><img src="examples/flower.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fstar.xml"><img src="examples/star.png" width="200" height="150"></a></td>
            </tr>
            <tr>
               <td><a href="MB.html?ex=examples%2fpinwheel.xml"><img src="examples/pinwheel.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2frainbow.xml"><img src="examples/rainbow.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fisland.xml"><img src="examples/island.png" width="200" height="150"></a></td>
            </tr>
            <tr>
               <td><a href="MB.html?ex=examples%2ffiddleheads.xml"><img src="examples/fiddleheads.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fstatic.xml"><img src="examples/static.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fmitosis.xml"><img src="examples/mitosis.png" width="200" height="150"></a></td>
            </tr>
            </table>
        </span>
    </span>
</td>
</tr>
</table>
<p id="message"></p>

<table border=0 cellpadding=0 cellspacing=0>
<tr valign="top"><td>
<div id="controls">
   <div class="group">
      <p><button id="restoreButton" title="Restore default limits, image size, palette, max iterations.">Restore Defaults</button><button id="stop" style="margin-left:20px" title="Abort the current computation, if any, leaving an incomplete image.">Stop</button></p>
   </div>
   <div class="group">
      <p><label title="If checked, lines in image are computed out of order.  This can give a general idea of the image more quickly."><input type="checkbox" id="interlaced">Interlaced Drawing</label></p>
      <p><label title="If checked, extra computations are done that can often give the completed image a smoother look, by computing two samples per pixel and averaging the resulting colors."><input type="checkbox" id="secondpass">Do a Second Pass</label></p>
      <p><label title="Increasing this can speed up the computation by utilizing more CPUs.">Workers: <select id="threadCountSelect">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
          <option value="10">10</option>
          <option value="12">12</option>
          <option value="16">16</option>
          <option value="24">24</option>
          <option value="32">32</option>
          <option value="48">48</option>
          <option value="64">64</option>
      </select></label></p>
      <p>
        <label id="localRemote" title="Run calculations locally in the browser or on the remote web server.">
        <input type="radio" id="local" name="location" value="local">
        <label for="local">Browser</label>
        <input type="radio" id="remote" name="location" value="remote">
        <label for="remote">Server</label></label>
      </p>
      <p>
        <label title="If checked, high precision arithmetic will be used even when its not needed (slower).">
        <input type="checkbox" id="highPrecision">High Precision</label>
      </p>
   </div>
   <div class="group">
      <p><button id="undo">Undo</button></p>
      <p><button id="redo">Redo</button></p>
   </div>
   <div class="group">
      <p><label title="Width and height of the Mandelbrot picture, in pixels.">Image Size: <select id="imagesize">
        <option value="0 0">Fit Window</option>
        <option value="640 480">640x480</option>
        <option value="800 600">800x600</option>
          <option value="1024 768">1024x768</option>
          <option value="1600 1200">1600x1200</option>
          <option value="1920 1080">1920x1080</option>
          <option value="1920 1200">1920x1200</option>
          <option value="2560 1440">2560x1440</option>
          <option value="2880 1800">2880x1800</option>
          <option value="3840 1080">3840x1080</option>
          <option value="3840 2160">3840x2160</option>
          <option value="5120 1440">5120x1440</option>
          <option value="7680 4320">7680x4320</option>
          <option value="Custom">Custom</option>
      </select></label><span id="customsize" style="display:none"><br><input type="text" maxlength="4" style="width:4ch" id="customwidth">x<input type="text" maxlength="4" style="width:4ch" id="customheight"> <button id="applysize">Apply</button></span></p>
   </div>
   <div class="group" id="maxIterSlider">
   </div>
   <div class="group">
      <p id="mainPaletteLengthSlider"></p>
      <p id="mainPaletteOffsetSlider"></p>
      <p id="paletteSelectSlider"></p>
      <p><button id="showpaletteedit" title="Show a popup dialog box that gives greater control over the palette.">Show Palette Editor</button>
            &nbsp;(<a href="palette-editor-info.png" target="_blank" title="Opens a guide to the Palette Editor in a separate tab or window.">info</a>)</p>
   </div>
   <div class="group">
      <p id="zoomInSlider"></p>
      <p id="zoomOutSlider"></p>
   </div>
   <div class="grouplast">
      <p><button id="importXML" title="Put up an input box into which you can copy-and-paste the XML code for an example, or get the XML for the current example.">Show XML Import/Export</button></p>
   </div>
</div>
<td>
  <div id="imagediv">
  <p id="status">Idle</p>
  <p><div id="canvas-holder">
     <canvas id="canvas" width="64" height="64"></canvas>
  </div></p>
  </div>
</td>
</tr>
</table>

<div id="xmlimportbg">
</div>
<div id="xmlimport">
<p>Mandelbrot examples can be coded as "XML documents."<br>
You can copy-and-paste the XML code for an example<br>
into this text input box.  Click "Apply" to import the<br>
example.  Click "Cancel" or press ESC to cancel. The <br>
"Grab Current Example" button loads the XML for the<br>
example that is currently shown in the program; this<br>
allows you to save the example (or even edit it by hand).</p>
<p><button style="margin-left:50px" id="applyXMLimport">Apply</button>
<button style="margin-left:20px" id="cancelXMLimport">Cancel</button>
<button style="margin-left:20px" id="grabcurrent">Grab Current Example</button></p>
<p><textarea rows="21" cols="55" id="XMLtextinput" placeholder="XML code goes here"></textarea>
</div>


<div id="paletteEditor">
<table bgcolor="#E8E8E8" cellpadding=3 cellspacing=0 border=2>
<tr>
   <td colspan=2>
      <table width=620 border=0>
      <tr><td align=left><button id="paletteEditStandardInstall"
             title="Click this button to replace the palette below with the standard palette that is selected on the right.">Install:</button>
          <select id="paletteEditStandardSelect" title="Click the button on the left to apply this palette in the palette editor.">
            <option value="Spectrum">Spectrum</option>
            <option value="EarthAndSky">EarthAndSky</option>
            <option value="Cyclic Fire">Fire</option>
            <option value="Seashore">Seashore</option>
            <option value="TreeColors">Forest</option>
            <option value="Pastels">Pastel Colors</option>
            <option value="Dark">Dark Colors</option>
            <option value="HotAndCold">HotAndCold</option>
            <option value="CyclicGrayscale">Grayscale</option>
            <option value="Random">Random</option>
          </select></td>
          <td align=right><button id="addcolorstop"
                title="Click to add a color stop to the palette below. The stop will be added next to the currently selected stop, if possible.  You can also add a stop by double-clicking the palette.">Add Color Stop</button>
                <button id="deletecolorstop" title="Click to delete the selected color stop. The first and last stops cannot be deleted.">Delete</button>
                <label style="margin-left:20pt" title="Check this box to lock the colors of the first and last color stops so that the two colors are forced to be the same.">Lock<input type="checkbox" id="lockcolors"></label>
          </td>
      </tr>
      </table>
      <p style="margin: 5px 0 0 0"><canvas id="coloredit" width=630 height=80
           title="Click a color stop to select it.  Drag selected color stop (except for the two at the ends) to move it.  Double-click in a free area to add a color stop."></canvas></p>
      <table border=0 cellpadding=0 style="margin:0 0 0 20px">
       <tr><td><canvas id="colorslider0" width=401 height=40
           title="Drag the slider to set the first color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput0" size=5 title="You can type a value for the first color component here, 0.0 to 1.0 for Red, anything greater than or equal to zero for Hue.">
           <span id="colorlabel0">Hue</span></td>
       </tr>
       <tr><td><canvas id="colorslider1" width=401 height=40
           title="Drag the slider to set the second color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput1" size=5 title="You can type a value for the second color component here, in the range 0.0 to 1.0.">
           <span id="colorlabel1">Saturation</span></td>
       </tr>
       <tr><td><canvas id="colorslider2" width=401 height=40
           title="Drag the slider to set the third color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput2" size=5 title="You can type a value for the third color component here, in the range 0.0 to 1.0.">
           <span id="colorlabel2">Brightness</span></td>
       </tr>
      </table>
   </td>
</tr>
<tr>
   <td valign=top>
      <canvas id="histogram" width=420 height=100
          title="Shows the distribution of iteration counts in the image, from 1 up to MaxIterations.  This can help with selecting a good palette length."></canvas>
      <p style="margin: 3px 0 0 9px"><canvas id="histogrampalette" width=408 height=22 style="display:inline"
          title="Shows how colors from palette will actually be applied to each iteration count, based on palette length and palette offset."></canvas></p>
      <table border=0 cellpadding=0 style="margin:3px 0 0 0">
       <tr><td colspan=2><canvas id="lengthslider" width=420 height=40
           title="Drag the slider to set the palette length.  Slider shows values between 1 and MaxIterations."></canvas></td>
       </tr>
       <tr><td align=right colspan=2>
              <input type=text id="editorlengthinput" size=5 
                  title="You can type a value for the palette length here.  It must be 1 or more.">Palette Length</td>
       </tr>
       <tr><td align=right><canvas id="offsetslider" width=250 height=40
           title="Drag the slider to set the palette offset as a percentage in the range 0 to 100."></canvas></td>
           <td align=left><input type=text id="editoroffsetinput" size=5 title="You can type a value for the palette offset percentage, in the range 0.0 to 100.0.">%&nbsp;&nbsp;Offset</td>
       </tr>
      </table>
   </td>
   <td valign=top width=200>
       <table border=0 cellpadding=0>
         <tr><td><canvas id="preview" width=200 height=200 
               title="A rough copy of the current image, with edited colors applied, giving a preview of the image with the edited palette."></td></tr>
         <tr><td><label title="If this box is unchecked, changes are only applied to the above preview when a drag action end.  Uncheck the box if your computer is having trouble keeping up as you drag a slider or color stop.">
               <input type=checkbox id="updateWhileDraggingCheck" checked>UpdateDuringDrag</label></td></tr>
       </table>
   </td>
</tr>
<tr>
   <td align=center  colspan=2>
   <button id="dismissPaletteEdit" title="Cancel palette editing, leaving colors in the image unchanged.">Cancel</button>
   <button id="revertPaletteEdit" title="Restore the palette to the its state when the palette editor was opened.">Revert Palette</button>
   <button id="applyPaletteEdit"  title="Dismiss the palette editor and apply the palette from the editor to the main image.">Apply and Close</button>
   </td>
</tr>
</table>
</div>

</body>
</html>
